{"componentChunkName":"component---src-templates-blog-template-js","path":"/cicd/","result":{"data":{"cur":{"id":"f3a2dcb8-b976-5324-9427-468e935a341e","html":"<h3 id=\"ci란\" style=\"position:relative;\"><a href=\"#ci%EB%9E%80\" aria-label=\"ci란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CI란?</h3>\n<ul>\n<li><code class=\"language-text\">빌드/테스트</code> 자동화 과정</li>\n<li>자동화 프로세스인 <code class=\"language-text\">지속적인 통합(Continuous Integration)</code>을 의미하는데, CI를 성공적으로 구현할 경우 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 리포지토리에 통합되므로 여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있음</li>\n<li><code class=\"language-text\">커밋할 때마다 빌드와 일련의 자동 테스트가 이루어져</code> 동작을 확인하고 변경으로 인해 문제가 생기는 부분이 없도록 보장</li>\n</ul>\n<h3 id=\"cd란\" style=\"position:relative;\"><a href=\"#cd%EB%9E%80\" aria-label=\"cd란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CD란?</h3>\n<ul>\n<li><code class=\"language-text\">배포</code> 자동화 과정</li>\n<li>지속적인 서비스 제공(Continuous Delivery) 또는 지속적인 배포(Continuous Deployment)를 의미하며 <code class=\"language-text\">상호 교환적</code>으로 사용됨</li>\n<li><code class=\"language-text\">지속적 배포</code>는 테스트 및 배포 단계를 자동화하는 DevOps 방식을 논리적 극한까지 끌어 올림\n<ul>\n<li>코드 변경이 파이프라인의 이전 단계를 모두 성공적으로 통과하면 수동 개입 없이 해당 변경 사항이 프로덕션에 자동으로 배포 됨</li>\n</ul>\n</li>\n<li><code class=\"language-text\">지속적 배포</code>는 또한 성숙하고 입증된 지속적 통합 및 지속적인 전달 단계를 기반으로 함\n<ul>\n<li>간단한 코드 변경이 정기적으로 마스터에 커밋되고, 자동화된 빌드 및 테스트 프로세스를 거치며 다양한 사전 프로덕션 환경으로 승격되며, 문제가 발생되지 않으면 최종적으로 배포됨</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://www.redhat.com/cms/managed-files/styles/wysiwyg_full_width/s3/ci-cd-flow-desktop.png?itok=2EX0MpQZ\" alt=\"CI/CD 프로세스\"></p>\n<h3 id=\"ci--cd-종류\" style=\"position:relative;\"><a href=\"#ci--cd-%EC%A2%85%EB%A5%98\" aria-label=\"ci  cd 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CI / CD 종류</h3>\n<ul>\n<li>Jenkins</li>\n<li>CircleCI</li>\n<li>TravisCI</li>\n<li>Github Actions</li>\n<li>etc</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#ci%EB%9E%80\">CI란?</a></li>\n<li><a href=\"#cd%EB%9E%80\">CD란?</a></li>\n<li><a href=\"#ci--cd-%EC%A2%85%EB%A5%98\">CI / CD 종류</a></li>\n</ul>\n</div>","excerpt":"CI란?  자동화 과정 자동화 프로세스인 을 의미하는데, CI를 성공적으로 구현할 경우 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 리포지토리에 통합되므로 여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있음  동작을 확인하고 변경으로 인해 문제가 생기는 부분이 없도록 보장 CD란?  자동화 과정 지속적인 서비스 제공(Continuous Delivery) 또는 지속적인 배포(Continuous Deployment)를 의미하며 으로 사용됨 는 테스트 및 배포 단계를 자동화하는 DevOps 방식을 논리적 극한까지 끌어 올림 코드 변경이 파이프라인의 이전 단계를 모두 성공적으로 통과하면 수동 개입 없이 해당 변경 사항이 프로덕션에 자동으로 배포 됨 는 또한 성숙하고 입증된 지속적 통합 및 지속적인 전달 단계를 기반으로 함 간단한 코드 변경이 정기적으로 마스터에 커밋되고, 자동화된 빌드 …","frontmatter":{"date":"December 09, 2022","title":"CI/CD에 대해서","categories":"블로그","author":"JungSany","emoji":"🚠"},"fields":{"slug":"/cicd/"}},"next":{"id":"58d79bc3-3b43-5ac6-ac65-8f268e81c801","html":"<h3 id=\"정의\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%9D%98\" aria-label=\"정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정의</h3>\n<ul>\n<li>애플리케이션을 트리의 각 노드들 즉, 일종의 나무와 같이 보고 나무를 흔들면 죽은 잎사귀들이 떨어지는 모습에 착안해 <code class=\"language-text\">Tree-shaking</code>이라고 명명하였다고 한다.</li>\n<li>사용하지 않는 코드를 제거하는 기법</li>\n</ul>\n<h3 id=\"방법\" style=\"position:relative;\"><a href=\"#%EB%B0%A9%EB%B2%95\" aria-label=\"방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>방법</h3>\n<ol>\n<li><strong>import시, 필요한 것만 작성하여 사용</strong></li>\n</ol>\n<ul>\n<li>사용하는 모듈로부터 <code class=\"language-text\">전체를 import 하지않고 사용하는 기능만 {} 부분적</code>으로 <code class=\"language-text\">import</code> 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 모들 유틸을 가져온다.</span>\n<span class=\"token comment\">// import utils from '../tensorflow/utils';</span>\n\n<span class=\"token comment\">// 위의 방법처럼 모든 유틸이 아닌 유틸의 일부만 가져온다.</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> drawKeyPoints<span class=\"token punctuation\">,</span> drawSkeleton <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../tensorflow/utils'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">drawCanvas</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">pose<span class=\"token punctuation\">,</span> video<span class=\"token punctuation\">,</span> videoWidth<span class=\"token punctuation\">,</span> videoHeight<span class=\"token punctuation\">,</span> canvas<span class=\"token punctuation\">,</span> flag</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> minPartConfidence <span class=\"token operator\">=</span> <span class=\"token number\">0.7</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> context <span class=\"token operator\">=</span> canvas<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2d'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  canvas<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span>width <span class=\"token operator\">=</span> videoWidth<span class=\"token punctuation\">;</span>\n  canvas<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> videoHeight<span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">drawSkeleton</span><span class=\"token punctuation\">(</span>pose<span class=\"token punctuation\">.</span>keypoints<span class=\"token punctuation\">,</span> minPartConfidence<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">drawKeyPoints</span><span class=\"token punctuation\">(</span>pose<span class=\"token punctuation\">.</span>keypoints<span class=\"token punctuation\">,</span> minPartConfidence<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> drawCanvas<span class=\"token punctuation\">;</span></code></pre></div>\n<ol>\n<li><strong>Babel이 ES6 모듈을 commonjs module로 변환하지 않도록 조치(.babelrc 설정)</strong></li>\n</ol>\n<ul>\n<li>Babel은 대부분의 웹 애플리케이션에서 필수로 사용하는 도구 중 하나 이지만 <code class=\"language-text\">babel-preset-env</code>를 사용중에 있다면 <code class=\"language-text\">ES6</code>를 자동으로 <code class=\"language-text\">commonjs</code>로 <code class=\"language-text\">변환</code>한다.</li>\n<li>좋은 기능이지만 트리 쉐이킹 관점에서는 그렇지 못하다고 한다.</li>\n<li><code class=\"language-text\">.babelrc</code>에서 <code class=\"language-text\">commonjs</code>로 변환하지 못하도록 설정을 추가해 줘야한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// “modules”: false를 지정하면, Babel이 디펜던시를 분석하고 사용되지 않는 디펜던시를 제거할 수 있다.</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">\"presets\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">\"env\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string-property property\">\"modules\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>또한 위와 같이 설정을 하면 웹팩은 코드를 광범위하게 호환되는 형식으로 변환하므로, 이 프로세스는 호환성 문제를 일으키지 않는다고 한다.</li>\n</ul>\n<ol>\n<li><strong>프로젝트의 모듈들이 Tree Shaking시, <code class=\"language-text\">Side Effect를 발생시키는지 여부를 확인</code>해야 한다.(package.json 설정)</strong></li>\n</ol>\n<ul>\n<li>예측 가능한 입력을 가지고 동일하게 함수의 스코프 밖에 어떤 것도 변경하지 않으면서 예측 가능한 결과를 반환하는 모듈이 안전하게 트리쉐이킹 할 수 있는 Dependency이다.</li>\n<li>이때 말하는 <code class=\"language-text\">**Side Effect**</code>의 예시는 아래와 같이 설명할 수 있을 것 같습니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 함수가 함수밖에 선언된 무언가를 변경할 때, 실행에 대한 Side Effect가 일어난다고할 수 있다.</span>\n<span class=\"token keyword\">let</span> sheriffs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'jung'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'gim'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'gong'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 이때 console을 찍으면 위에 배열안의 요소만 출력된다. [\"jung\", \"gim\", \"gong\"]</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sheriffs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">addSheriff</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">sheriff</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  sheriffs<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>sheriff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 아래의 함수는 sheriffs의 배열을 변경할 때 Side Effect를 발생시킨다.</span>\n<span class=\"token function\">addSheriff</span><span class=\"token punctuation\">(</span><span class=\"token string\">'pack'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sheriffs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [\"jung\", \"gim\", \"gong\", \"pack\"]</span></code></pre></div>\n<ul>\n<li>이때 웹팩을 설정하여 <code class=\"language-text\">Side Effect 옵션 체킹</code>이 가능하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token comment\">// \"sideEffects\": false를 설정하면 패키지와 Dependency들이 Side Effect를 발생하지 않게 막는다.</span>\n<span class=\"token comment\">// Side Effect가 일어나는 것에 대해서 웹팩에서 판단하지않고 개발자가 위임받아 개발자가 알아서 처리하는 방식</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"poke_poke_coaching\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"sideEffects\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 특정 파일을 지정하여 선택적으로 사이드 이펙트의 영향을 받지 않도록 설정</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"poke_poke_coaching\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"sideEffects\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token string\">\".src/util/helpers/drawCanvas.js\"</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"생각\" style=\"position:relative;\"><a href=\"#%EC%83%9D%EA%B0%81\" aria-label=\"생각 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>생각</h3>\n<ul>\n<li>이러한 작업들이 서비스 개발 단계에 있어서 큰 영향을 미치진 않겠지만, 이런 디테일한 작업들이 습관화 된다면 결국 서비스의 퀄리티를 결정하는 요소라고 생각한다.</li>\n<li>하지만 위의 방법으로 인해 문제가 생기는 경우가 있는가에 대해서는 더 찾아봐야 할 것 같다.</li>\n<li>그리고 로데쉬 함수로도 트리쉐이킹 방법이 있다고 하니 추가적으로 알아봐야 될 것이 있는 것 같다.</li>\n</ul>\n<h3 id=\"용어정리\" style=\"position:relative;\"><a href=\"#%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC\" aria-label=\"용어정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>용어정리</h3>\n<p>Side Effect: <code class=\"language-text\">의도치않은 결과, 렌더링 중에 발생하는 것이 아니라 \"측면\"에서 발생하는 것</code> 또는 함수가 실행되면 함수 외부에 존재하는 값이나 상태를 변경시키는 등의 행위</p>\n<ul>\n<li><code class=\"language-text\">절차형 프로그래밍</code>에서는 Side Effect가 흔히 존재하였고, 이는 프로그램을 읽기 어렵게하고 실행상태를 예측하기 어렵게 하며 개발비용을 증가 시켰다.</li>\n<li>이에 따라 <code class=\"language-text\">선언형 프로그래밍</code> 방식으로 지향하게 되면서 Side Effect를 최소화 하는 방향으로 바뀌고 있다.\n<ul>\n<li>선언형 프로그래밍 방식을 사용하게 되면 함수가 매개변수를 통해 연산을 수행하게 되면 함수에 작성된 로직대로 <code class=\"language-text\">일관되고 예측 가능한 결과과 반환</code>되기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%A0%95%EC%9D%98\">정의</a></li>\n<li><a href=\"#%EB%B0%A9%EB%B2%95\">방법</a></li>\n<li><a href=\"#%EC%83%9D%EA%B0%81\">생각</a></li>\n<li><a href=\"#%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC\">용어정리</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 09, 2022","title":"트리 쉐이킹(Tree Shaking)","categories":"블로그 featured","author":"JungSany","emoji":"🧹"},"fields":{"slug":"/treeshaing/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"https://rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/cicd/","nextSlug":"/treeshaing/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/typescript/differences-from-javscript/","result":{"data":{"cur":{"id":"a26a5b52-3827-5bef-935a-18541a95e568","html":"<p><img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&#x26;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb49XWa%2FbtrnpormQUO%2FJyyh5YnhCxpm5o8PMRAM8K%2Fimg.png\" alt=\"자바스크립트와 타입스크립트 이미지\"></p>\n<h2 id=\"우선-이것부터\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0-%EC%9D%B4%EA%B2%83%EB%B6%80%ED%84%B0\" aria-label=\"우선 이것부터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선 이것부터</h2>\n<p><strong><code class=\"language-text\">TypeScript</code>는 JavaScript 기반의 언어</strong></p>\n<p><code class=\"language-text\">JavaScript</code>는 클라이언트 측 스크립팅 언어이고, <code class=\"language-text\">TypeScript</code>는 객체 지향 컴파일 언어</p>\n<br/>\n<h2 id=\"javascript\" style=\"position:relative;\"><a href=\"#javascript\" aria-label=\"javascript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaScript</h2>\n<p><strong><code class=\"language-text\">동적 타입 언어</code>이며, <code class=\"language-text\">런타임 속도</code>는 <code class=\"language-text\">빠르지만 타입 안정성이 보장되지 않</code>는다.</strong></p>\n<p>웹 개발에 주로 사용됨</p>\n<p>폼 유효성 검사, 애니메이션 적용 및 이벤트 생성을 수행</p>\n<p><a href=\"https://rnfltpgus.github.io/javascript/event-loop/\">사용자가 웹 브라우저를 열고 웹 페이지를 요청하면 해당 요청이 웹 서버로 이동함\n멀티 스레딩, 멀티 프로세싱 기능이 없음</a></p>\n<br/>\n<h2 id=\"typescript\" style=\"position:relative;\"><a href=\"#typescript\" aria-label=\"typescript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript</h2>\n<p><strong><code class=\"language-text\">정적 타입 언어</code>이며, <code class=\"language-text\">컴파일 시간이 조금 걸리</code>지만, <code class=\"language-text\">안정성이 보장된</code>다.</strong></p>\n<p>JavaScript의 상위 집합으로 JavaScript의 모든 기능이 있음</p>\n<p>TypeScript 컴파일러를 사용하여 ts(TypeScript)파일을 js(JavaScript) 파일로 변환과 통합이 쉽다.</p>\n<p>클래스 기반 객체를 만들 수 있다.</p>\n<p>클래스 기반이므로 객체 지향 프로그래밍 언어로 상속, 캡슐화 및 생성자를 지원할 수 있다.</p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%9A%B0%EC%84%A0-%EC%9D%B4%EA%B2%83%EB%B6%80%ED%84%B0\">우선 이것부터</a></li>\n<li><a href=\"#javascript\">JavaScript</a></li>\n<li><a href=\"#typescript\">TypeScript</a></li>\n</ul>\n</div>","excerpt":"자바스크립트와 타입스크립트 이미지 우선 이것부터 는 JavaScript 기반의 언어 는 클라이언트 측 스크립팅 언어이고, 는 객체 지향 컴파일 언어 JavaScript 이며, 는 는다. 웹 개발에 주로 사용됨 폼 유효성 검사, 애니메이션 적용 및 이벤트 생성을 수행 사용자가 웹 브라우저를 열고 웹 페이지를 요청하면 해당 요청이 웹 서버로 이동함\n멀티 스레딩, 멀티 프로세싱 기능이 없음 TypeScript 이며, 지만, 다. JavaScript의 상위 집합으로 JavaScript의 모든 기능이 있음 TypeScript 컴파일러를 사용하여 ts(TypeScript)파일을 js(JavaScript) 파일로 변환과 통합이 쉽다. 클래스 기반 객체를 만들 수 있다. 클래스 기반이므로 객체 지향 프로그래밍 언어로 상속, 캡슐화 및 생성자를 지원할 수 있다. 우선 이것부터 JavaScript TypeScript","frontmatter":{"date":"January 04, 2023","title":"JavaScript와 TypeScript 차이점","categories":"TypeScript JavaScript","author":"JungSany","emoji":"🧐"},"fields":{"slug":"/typescript/differences-from-javscript/"}},"next":{"id":"3e8db353-67f2-53d6-b54a-63aeb0321510","html":"<h2 id=\"우선-memoization이란\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0-memoization%EC%9D%B4%EB%9E%80\" aria-label=\"우선 memoization이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선 Memoization이란?</h2>\n<p><strong>기존에 수행한 연산의 결과값을 어딘가에 저장해두고 동일한 입력이 들어오면 재활용하는 프로그래밍 기법 이다.</strong></p>\n<p><code class=\"language-text\">memoization</code>을 절적히 적용하면 <strong>중복 연산을 피할 수 있기 때문에 메모리를 조금 더 쓰더라도 애플리케이션의 성능을 최적화</strong>할 수 있습니다.</p>\n<br/>\n<h2 id=\"그리고-react에서-컴포넌트를-다시-실행하는-경우는-아래와-같다\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A6%AC%EA%B3%A0-react%EC%97%90%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%8B%A4%EC%8B%9C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0%EB%8A%94-%EC%95%84%EB%9E%98%EC%99%80-%EA%B0%99%EB%8B%A4\" aria-label=\"그리고 react에서 컴포넌트를 다시 실행하는 경우는 아래와 같다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>그리고 React에서 컴포넌트를 다시 실행하는 경우는 아래와 같다.</strong></h2>\n<ol>\n<li>부모 컴포넌트가 재실행될 때</li>\n<li>props가 변경될 때</li>\n<li>state가 변경되었을 때</li>\n</ol>\n<br/>\n<h2 id=\"reactmemo란\" style=\"position:relative;\"><a href=\"#reactmemo%EB%9E%80\" aria-label=\"reactmemo란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>React.memo란?</strong></h2>\n<p>React.memo는 <strong>High Order Components(HOC)</strong> 이다.</p>\n<p>일반 컴포넌트는 인자로 받은 props를 UI에 활용하는 반면, HOC는 인자로 받은 컴포넌트를 새로운 별도의 컴포넌트로 만든다.</p>\n<p>HOC는 리액트의 API가 아니라, <strong>리액트가 컴포넌트를 구성하는 데 있어서 일종의 패턴</strong>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Movie</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> title<span class=\"token punctuation\">,</span> description <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Movie title: </span><span class=\"token punctuation\">{</span>title<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Release date: </span><span class=\"token punctuation\">{</span>description<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> MemoizedMovie <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>Movie<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><strong>만약 <code class=\"language-text\">컴포넌트가 같은 props를 받을 때 같은 결과를 렌더링한다면</code> React.memo를 사용하여 <code class=\"language-text\">메모이징(Memoizing)된 내용</code>을 <code class=\"language-text\">재사용</code>하여, 불필요한 렌더링을 방지할 수 있다.</strong></li>\n<li>React.memo는 <code class=\"language-text\">오직 props가 변경됐는지 아닌지만 확인</code>한다. 하지만, 함수형 컴포넌트가 함수 내부에서 useState와 같은 Hook을 사용하고 있는 경우에는 상태가 변경 되면 리렌더링 된다.</li>\n</ul>\n<h3 id=\"사용은-언제-해야-될까\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EC%9D%80-%EC%96%B8%EC%A0%9C-%ED%95%B4%EC%95%BC-%EB%90%A0%EA%B9%8C\" aria-label=\"사용은 언제 해야 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용은 언제 해야 될까?</h3>\n<p>같은 props로 렌더링이 자주 일어나는 컴퍼넌트에 대해서 사용하면 좋다고 한다. 잘 알지 못한 상태로 React.memo()를 적용하려고 한다면 필요없는 props 비교하는 상황이 생겨 오히려 성능을 악화시킬 수 있으니 잘 이해하고 쓰는 편이 좋을 것 같다.</p>\n<br/>\n<h2 id=\"usememo란\" style=\"position:relative;\"><a href=\"#usememo%EB%9E%80\" aria-label=\"usememo란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>useMemo란?</strong></h2>\n<p><strong>useMemo는 메모이즈된 값을 return하는 Hook이다.</strong></p>\n<p><strong>useMemo는 이전 값을 기억해두었다가 조건에 따라 재활용하여 성능을 최적화 하는 용도로 사용된다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Movie</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> memoizedMemo <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>memoizedMemo<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>인자로 함수와 Dependencies를 넘겨 받는다. 의존 인자 중에 하나라도 값이 변경되면 1번째 인자의 함수가 재실행된다. 이를 통해 매 렌더링될 때마다 소요되는 불필요한 함수의 실행을 막을 수 있다.</li>\n<li>인자가 빈 배열이라면 매번 새롭게 함수가 실행되어 return한다.</li>\n</ul>\n<h3 id=\"유의사항\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EC%9D%98%EC%82%AC%ED%95%AD\" aria-label=\"유의사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유의사항</h3>\n<p>모든 컴포넌트를 useMemo로 감싸게 되면 이 또한 리소스 낭비이므로, 퍼포먼스 최적화가 필요한 연상량이 많은 곳에 사용하는 것이 좋다.</p>\n<br/>\n<h2 id=\"usecallback란\" style=\"position:relative;\"><a href=\"#usecallback%EB%9E%80\" aria-label=\"usecallback란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>useCallback란?</strong></h2>\n<p><strong><code class=\"language-text\">useCallback</code>은 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용한다.</strong></p>\n<p><strong><code class=\"language-text\">함수를 메모이제이션하기 위해 사용</code>되는 hook 함수로</strong></p>\n<p><strong>useMemo와의 차이는</strong></p>\n<ul>\n<li><code class=\"language-text\">useMemo</code>는 특정 결과값을 재사용할 때 사용하는 반면, <code class=\"language-text\">useCallback</code>은 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용한다는 점이 차이이다.</li>\n</ul>\n<h3 id=\"사용방법은\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95%EC%9D%80\" aria-label=\"사용방법은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용방법은</h3>\n<p>첫번째 인자로 넘어온 함수를, 두번쨰 인자로 넘어온 배열 내의 값이 변경될때까지 저장해 놓고 재사용할 수 있게 해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> memoizedCallback <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span>함수<span class=\"token punctuation\">,</span> 배열<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>예를 들어, 어떤 React 컴포넌트 함수 안에 함수가 선언이 되어 있다면 그 함수는 해당 컴포넌트가 랜더링될 때 마다 새로운 함수를 생성하게 되는데</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">useCallback()</code>을 사용하면, 해당 컴포넌트가 랜더링되더라도 그 함수가 의존하는 값들이 바뀌지 않는 한 기존 함수를 계속해서 반환한다.</p>\n<p>즉, <code class=\"language-text\">x</code> 또는 <code class=\"language-text\">y</code> 값이 바뀌면 새로운 함수가 생성되어 <code class=\"language-text\">add</code> 변수에 할당되고, <code class=\"language-text\">x</code> 와 <code class=\"language-text\">y</code> 값이 동일하다면 다음 랜더링 때 이 함수를 재사용한다.</p>\n<br/>\n<h2 id=\"잡썰\" style=\"position:relative;\"><a href=\"#%EC%9E%A1%EC%8D%B0\" aria-label=\"잡썰 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>잡썰</h2>\n<ol>\n<li>성능에 관한 최적화를 하는 함수라고 하여도 아무떄나 사용하는 것이 아닌 코드적으로 이용을 하여 <code class=\"language-text\">성능적인 퍼포먼스를 낼 수 있는가를 생각해 보아야 된다</code>는 것을 알게 되었다.</li>\n<li><code class=\"language-text\">useCallback()</code> hook 함수는 자식 컴포넌트의 랜더링의 불필요한 랜더링을 줄이기 위해서 <code class=\"language-text\">React.memo()</code> 함수와 같이 사용하면 좋다는 글을 보았는데 이 부분은 경험을 해보아야 느껴질 것 같다.</li>\n</ol>\n<br/>\n<h2 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Memoization\">wikipedia- Memoization</a></p>\n<p><a href=\"https://ui.toast.com/weekly-pick/ko_20190731\">React.memo() 현명하게 사용하기</a></p>\n<p><a href=\"https://www.daleseo.com/react-hooks-use-memo/\">React Hooks: useMemo 사용법</a></p>\n<p><a href=\"https://www.daleseo.com/react-hooks-use-callback/\">React Hooks: useCallback 사용법</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%9A%B0%EC%84%A0-memoization%EC%9D%B4%EB%9E%80\">우선 Memoization이란?</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%A6%AC%EA%B3%A0-react%EC%97%90%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%8B%A4%EC%8B%9C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0%EB%8A%94-%EC%95%84%EB%9E%98%EC%99%80-%EA%B0%99%EB%8B%A4\"><strong>그리고 React에서 컴포넌트를 다시 실행하는 경우는 아래와 같다.</strong></a></p>\n</li>\n<li>\n<p><a href=\"#reactmemo%EB%9E%80\"><strong>React.memo란?</strong></a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%EC%9D%80-%EC%96%B8%EC%A0%9C-%ED%95%B4%EC%95%BC-%EB%90%A0%EA%B9%8C\">사용은 언제 해야 될까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#usememo%EB%9E%80\"><strong>useMemo란?</strong></a></p>\n<ul>\n<li><a href=\"#%EC%9C%A0%EC%9D%98%EC%82%AC%ED%95%AD\">유의사항</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#usecallback%EB%9E%80\"><strong>useCallback란?</strong></a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95%EC%9D%80\">사용방법은</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%A1%EC%8D%B0\">잡썰</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 02, 2023","title":"Hooks의 React.memo과 useMemo 그리고 useCallback에 대해서","categories":"React","author":"JungSany","emoji":"👊"},"fields":{"slug":"/react/hooks-use/hooks-difference/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/typescript/differences-from-javscript/","nextSlug":"/react/hooks-use/hooks-difference/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/left-inner-join/","result":{"data":{"cur":{"id":"c69803b4-208d-5f30-a6bf-8e42eccd82bc","html":"<ul>\n<li>각 주제에 따라 테이블을 나누어 작성한 후, 정보를 가져오는 경우 <code class=\"language-text\">테이블을 합치는 경우</code>가 있다.</li>\n<li>이때 <code class=\"language-text\">JOIN</code>을 사용하게 되는데, 그 중 많이 사용하는 것이 <code class=\"language-text\">LEFT JOIN</code>과 <code class=\"language-text\">INNER JOIN</code>이다.</li>\n</ul>\n<br/>\n<h3 id=\"차이점\" style=\"position:relative;\"><a href=\"#%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차이점</h3>\n<ul>\n<li>두 테이블에서 <code class=\"language-text\">JOIN</code>을 위한 <strong>기준 열이 서로 값을 가지고 있는 경우</strong> 조회에서 <strong>누락되는 행은 존재하지 않는다.</strong></li>\n<li>그렇다면 <code class=\"language-text\">LEFT JOIN</code>과 <code class=\"language-text\">INNER JOIN</code>은 같은 조회 결과를 보인다. 이때, <strong><code class=\"language-text\">INNER JOIN</code>이 상대적으로 성능이 좋다</strong>고 한다.</li>\n</ul>\n<br/>\n<h3 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h3>\n<ul>\n<li><code class=\"language-text\">LEFT JOIN</code>은 <strong>합집합</strong>, <code class=\"language-text\">INNER JOIN</code>은 <strong>교집합</strong>이다.</li>\n<li>결과가 같다면 <code class=\"language-text\">LEFT JOIN</code>대신 <code class=\"language-text\">INNER JOIN</code> 을 사용하는게 좋다.</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%B0%A8%EC%9D%B4%EC%A0%90\">차이점</a></li>\n<li><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></li>\n</ul>\n</div>","excerpt":"각 주제에 따라 테이블을 나누어 작성한 후, 정보를 가져오는 경우 가 있다. 이때 을 사용하게 되는데, 그 중 많이 사용하는 것이 과 이다. 차이점 두 테이블에서 을 위한 기준 열이 서로 값을 가지고 있는 경우 조회에서 누락되는 행은 존재하지 않는다. 그렇다면 과 은 같은 조회 결과를 보인다. 이때, 이 상대적으로 성능이 좋다고 한다. 결론 은 합집합, 은 교집합이다. 결과가 같다면 대신  을 사용하는게 좋다. 차이점 결론","frontmatter":{"date":"December 13, 2022","title":"SQL - LEFT JOIN, INNER JOIN 차이","categories":"개발지식 데이터","author":"JungSany","emoji":"📂"},"fields":{"slug":"/left-inner-join/"}},"next":{"id":"c68ce03d-c589-5507-b1b2-70e44876e320","html":"<h3 id=\"sql관계형-db\" style=\"position:relative;\"><a href=\"#sql%EA%B4%80%EA%B3%84%ED%98%95-db\" aria-label=\"sql관계형 db permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL(관계형 DB)</h3>\n<ul>\n<li>\n<p>SQL을 사용하면 RDBMS(관리 시스템)에서 데이터를 저장, 수정, 삭제 및 검색할 수 있음</p>\n</li>\n<li>\n<p>관계형 데이터베이스의 핵심 특징</p>\n<ul>\n<li>데이터는 <code class=\"language-text\">정해진 데이터 스키마에 따라</code> 테이블에 저장된다.</li>\n<li>데이터는 <code class=\"language-text\">관계를 통해</code> 여러 테이블에 분산된다.</li>\n</ul>\n</li>\n<li>\n<p>데이터는 테이블에 레코드로 저장되는데, 각 테이블마다 명확하게 정의된 구조가 있다.</p>\n</li>\n<li>\n<p>해당 <code class=\"language-text\">구조는 필드의 이름과 데이터 유형</code>으로 정의된다.</p>\n</li>\n<li>\n<p>따라서 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다. 즉, 스키마를 수정하지 않은 이상 정해진 구조에 맞는 레코드만 추가가 가능한 것이 관계형 데이터베이스의 특징 중 하나다.</p>\n</li>\n<li>\n<p>또한, 데이터 중복을 피하기 위해 ‘관계’를 이용한다.\n<img src=\"https://camo.githubusercontent.com/3c8dd62be5799ccada4e2da75f1ccfb458eea2e8/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393934443039333535433933374543443244\" alt=\"데이터 중복을 피하기 위한 데이터 관계 예시\"></p>\n</li>\n<li>\n<p><strong>하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에 다른 테이블에서 부정확 데이터를 다룰 위험이 없어지는 장점이 있다.</strong></p>\n</li>\n</ul>\n<br/>\n<h3 id=\"nosql비관계형-db\" style=\"position:relative;\"><a href=\"#nosql%EB%B9%84%EA%B4%80%EA%B3%84%ED%98%95-db\" aria-label=\"nosql비관계형 db permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL(비관계형 DB)</h3>\n<ul>\n<li>\n<p>SQL(관계형 DB)와 반대로 스키마도 없고, 관계도 없다.</p>\n</li>\n<li>\n<p>NOSQL에서는 레코드를 문서(documents)라고 부른다.</p>\n</li>\n<li>\n<p>여기서 SQL과 핵심적인 차이가 있는데, SQL은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능했다. 하지만 NOSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능하다.</p>\n</li>\n<li>\n<p>문서(documents)sms Json과 비슷한 형태로 가지고 있다. 관계형 데이터베이스처럼 여러 테이블에 나누어담지 않고, 관련 데이터를 동일한 <code class=\"language-text\">컬렉션</code>에 넣는다.</p>\n</li>\n<li>\n<p>따라서 위 사진에 SQL에서 진행한 Order, Users, Products 테이블로 나눈 것을 NoSQL에서는 Orders에 한꺼번에 포함해서 저장하게 된다.</p>\n</li>\n<li>\n<p>따라서 여러 테이블에 조인할 필요없이 이미 필요한 모든 것을 갖춘 문서를 작성하는 것이 NoSQL이다.(NoSQL에는 조인이라는 개념이 존재하지 않음)</p>\n</li>\n<li>\n<p>NoSQL에서 조인을 하고싶을 경우 <code class=\"language-text\">컬랙션을 통해 데이터를 복제하여 각 컬렉션 일부분에 속하는 데이터를 정확하게 산출</code>하도록 한다.</p>\n</li>\n<li>\n<p>하지만 이러면 데이터가 중복되어 서로 영향을 줄 위험이 있다. 따라서 조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 때 NoSQL을 쓰면 상당히 효율적이다.</p>\n</li>\n</ul>\n<br/>\n<h3 id=\"확장-개념\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5-%EA%B0%9C%EB%85%90\" aria-label=\"확장 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장 개념</h3>\n<ul>\n<li>데이터베이스 서버의 확장성은 ‘수직적’ 확장과 ‘수평적’ 확장으로 나누어 진다.\n<ul>\n<li>수직적 확장: 단순히 데이터베이스 서버의 성능을 향상시키는 것(ex. CPU 업그레이드)</li>\n<li>수평적 확장: 더 많은 서버가 추가되고 데이터베이스가 적체적으로 분산됨을 의미(하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)</li>\n</ul>\n</li>\n<li>데이터 저장 방식으로 인해 SQL 데이터베이스는 일반적으로 수직적 확장만 지원함\n<ul>\n<li>수평적 확장은 NoSQL 데이터베이스에서만 가능</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"장--단점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5--%EB%8B%A8%EC%A0%90\" aria-label=\"장  단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장 / 단점</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>SQL</th>\n<th>NOSQL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>장점</td>\n<td>- 명확하게 정의된 스키마, 데이터 무결성 보장</td>\n<td>- 스키마가 없어서 유연함</td>\n</tr>\n<tr>\n<td></td>\n<td>- 관계는 각 데이터를 중복없이 한번만 저장</td>\n<td>- 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>- 데이터는 애플리케이션이 필요로 하는 형식으로 저장</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>- 데이터 읽어오는 속도가 빨라짐 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능</td>\n</tr>\n<tr>\n<td>단점</td>\n<td>- 덜 유연함</td>\n<td>- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음</td>\n</tr>\n<tr>\n<td></td>\n<td>- 데이터 스키마를 사전에 계획하고 알려야 함</td>\n<td>- 데이터 중복을 계속 업데이트 해야 함</td>\n</tr>\n<tr>\n<td></td>\n<td>- 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음</td>\n<td>- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함</td>\n</tr>\n<tr>\n<td></td>\n<td>- 대체로 수직적 확장만 가능</td>\n<td>- SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능</td>\n</tr>\n<tr>\n<td>사용하는 경우 더 좋을 때</td>\n<td>- 데이터가 자주 변경되는 애플리케이션의 경우(NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적)</td>\n<td>- 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우</td>\n</tr>\n<tr>\n<td></td>\n<td>- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우</td>\n<td>- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>- 데이터베이스를 수평으로 확장해야 하는 경우(막대한 양의 데이터를 다뤄야 하는 경우)</td>\n</tr>\n</tbody>\n</table>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://www.oracle.com/kr/database/what-is-database/\">oracle 데이터베이스란?</a></p>\n<p><a href=\"https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-sql-vs-nosql/\">[데이터베이스] SQL(구조화 쿼리 언어) vs NoSQL(비구조화 쿼리 언어) - 하나몬</a></p>\n<br />\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#sql%EA%B4%80%EA%B3%84%ED%98%95-db\">SQL(관계형 DB)</a></li>\n<li><a href=\"#nosql%EB%B9%84%EA%B4%80%EA%B3%84%ED%98%95-db\">NoSQL(비관계형 DB)</a></li>\n<li><a href=\"#%ED%99%95%EC%9E%A5-%EA%B0%9C%EB%85%90\">확장 개념</a></li>\n<li><a href=\"#%EC%9E%A5--%EB%8B%A8%EC%A0%90\">장 / 단점</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 13, 2022","title":"SQL과 NOSQL 차이","categories":"개발지식 데이터","author":"JungSany","emoji":"🗂️"},"fields":{"slug":"/sql-nosql/"}},"prev":{"id":"4e3adcd4-fb92-519b-bdfb-4a59b70dfbcd","html":"<h3 id=\"cache\" style=\"position:relative;\"><a href=\"#cache\" aria-label=\"cache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cache</h3>\n<ul>\n<li>물건을 일시적으로 저장, 보관하기 위해 사용하는 곳이라는 사전적 의미를 가지고 있는데</li>\n<li>개발 기술적인 Cache의 뜻으로는 <code class=\"language-text\">자주 필요한 데이터나 값</code>의 복사본을 <code class=\"language-text\">일시적</code>으로 <code class=\"language-text\">저장, 보관하기 위해 사용하는 곳</code>을 말한다.</li>\n</ul>\n<br/>\n<h3 id=\"caching\" style=\"position:relative;\"><a href=\"#caching\" aria-label=\"caching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caching</h3>\n<ul>\n<li><strong><code class=\"language-text\">Cache</code>에 데이터나 계산된 결과 값의 복사본을 저장해 둠으로써 전체적인 처리 속도를 향상 시킨다.</strong>\n<ul>\n<li>데이터에 직접적으로 접근하는데 걸리는 시간이 오래 걸릴 때</li>\n<li>필요한 값을 얻기 위해 계산하는 과정을 생략하고 싶을 때</li>\n<li>반복적으로 동일한 결과를 돌려주는 경우(이미지나 썸네일 등)</li>\n</ul>\n</li>\n<li><code class=\"language-text\">Caching</code>은 복사본을 이용하는 것이다.</li>\n<li>하지만 복사본과 <code class=\"language-text\">원본이 달라지는 경우</code>가 생길 수 있으니 <code class=\"language-text\">일관성 유지</code>에 유의해야 한다.</li>\n</ul>\n<br/>\n<h3 id=\"컴퓨터의-동작원리\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"컴퓨터의 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴퓨터의 동작원리</h3>\n<p><img src=\"https://images.velog.io/images/mee9204/post/fb39e719-9435-478b-8044-98d665d30912/hardware_img.png\" alt=\"컴퓨터의 동작원리\"></p>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>RAM</th>\n<th>Hard Drive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>중앙처리장치</td>\n<td>주기억장치</td>\n<td>보조기억장치</td>\n</tr>\n<tr>\n<td>매우 빠름</td>\n<td>빠름</td>\n<td>매우 느림</td>\n</tr>\n<tr>\n<td>기억장치에서 데이터를 받아들여 연산작업</td>\n<td>전원이 꺼지면 데이터가 지워짐</td>\n<td>전원이 꺼져도 데이터가 지워지지 않음</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>RAM은 하드 디스크에서 데이터를 불러오고 CPU는 RAM에 저장되어 있는 데이터를 이용하여 연산 작업을 수행하는 구조이다.</li>\n<li>CPU가 <code class=\"language-text\">데이터처리를 위해</code> RAM과 작업을 진행하게 되는데 <code class=\"language-text\">RAM이를 따라가지 못하는 경우</code> 데이터 <code class=\"language-text\">병목현상</code>이 일어난다.</li>\n<li>이를 완화하기 위해 CPU와 RAM 사이에 크기는 작지만 속도가 빠른 <code class=\"language-text\">Cache Memory</code>를 두고, 향후 <code class=\"language-text\">재사용</code>할 가능성이 클 것으로 <code class=\"language-text\">예상되는 데이터의 복사본을 저장</code>해둔 후 CPU가 <code class=\"language-text\">요청</code>하는 데이터를 <code class=\"language-text\">바로바로 전달</code>할 수 있게 해준다.</li>\n</ul>\n<p><img src=\"https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&#x26;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F991E7C365CBF4BFF01\" alt=\"메모리피라미드\"></p>\n<ul>\n<li><code class=\"language-text\">메인 메모리</code>는 <strong>DRAM</strong>, <code class=\"language-text\">캐시 메모리</code>는 <strong>SRAM</strong>의 구조를 가지는데, 그 안에는 <code class=\"language-text\">트랜지스터</code>(전류를 제어하는 데 사용하는 전류 구동 반도체 소자)라는 것이 존재한다.\n<ul>\n<li><strong>DRAM은 한 셀당 트랜지스터 1개</strong></li>\n<li><strong>SRAM은 한 셀당 트랜지스터 6개</strong></li>\n</ul>\n</li>\n<li>피라미드 구조 이미지에서 위 단계에 있을 수록 빠르고, 가격이 비싸며, 작은 용량을 가지며 CPU와 가까이 위치한다.</li>\n<li><code class=\"language-text\">캐싱</code>은 CPU와 RAM 사이에서만 사용되는 것이 아니라, 위 피라미드 구조 단계 사이사이에서도 캐싱이 이루어 진다. (CPU → Cache Memory, Cache Memory → RAM 이런식으로 단계별 아래 계층에 대하여 캐싱 작업을 수행)</li>\n<li><strong>이러한 <code class=\"language-text\">메모리 계층 구조의 목적</code>은 캐싱을 이용하여 빠르고 작은 메모리와 크고 느린 메모리의 장점을 조합해서 크고 빠른 메모리처럼 행동하도록 만들기 위함이다.</strong></li>\n</ul>\n<br/>\n<h3 id=\"캐시-동작-원리\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\" aria-label=\"캐시 동작 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시 동작 원리</h3>\n<ul>\n<li>어떤 부분이 재사용성할 가능성이 큰지 알아보는 방법?\n<ul>\n<li>데이터 지역성의 원리를 통하여 데이터 접근이 시간적 혹은 공간적으로 가깝게 일어나는 것을 의미하는데</li>\n<li>시간 지역성\n<ul>\n<li>특정 데이터가 한번 접근되었을 경우, 가까운 미래에 또 한번 데이터에 접근할 가능성이 높은 것</li>\n<li>메모리 상의 같은 주소에 여러 차례 읽기 쓰기를 수행할 경우 상대적으로 작은 크기의 캐시를 사용해도 효율성을 높일 수 있음</li>\n<li>ex) for나 while문의 조건 변수 i</li>\n</ul>\n</li>\n<li>공간 지역성\n<ul>\n<li>특정 데이터와 가까운 주소가 순서대로 접근되는 경우</li>\n<li>한 메모리 주소에 접근할 때 그 주소뿐 아니라 해당 블록을 전부 캐시에 가져옴</li>\n<li>이때 메모리 주소를 오름차순이나 내림차순으로 접근한다면, 캐시에 이미 저장된 같은 블록의 데이터를 접근하게 되므로 캐시의 효율성이 크게 향상될 수 있음</li>\n<li>ex) 배열은 순서대로 접근할 가능성이 크다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>캐시 메모리가 해당 데이터를 가지고 있다면 <code class=\"language-text\">캐시 히트(캐시 적중)</code>이라 하며, 해당 데이터가 없어서 메인 메모리에서 가져와야 한다면 <code class=\"language-text\">캐시 미스</code>라고 한다.</li>\n<li><strong>Write Through 정책</strong>\n<ul>\n<li>메인 메모리를 바로 업데이트하는 경우를 말하는데</li>\n<li>단순하고 캐시와 메인 메모리의 일관성을 유지할 수 있지만, 매번 바꿔줘야 되므로 느리다는 단점이 존재한다.</li>\n</ul>\n</li>\n<li><strong>Write Back 정책</strong>\n<ul>\n<li>캐시만 업데이트 하다가, 업데이트된 데이터가 캐시에서 빠지게 될 때 메인 메모리를 업데이트 해주는 정책이다.</li>\n<li><code class=\"language-text\">업데이트 확인</code>은 캐시 블록마다 dirty 비트를 추가해야 되며, 데이터가 변경되었다면 dirty 비트가 1로 변경된다. ( 해당 dirty 비트에 대해서는 알아봐야 할 듯 하다.)</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p>우테코 영상을 보고 정리 중</p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#cache\">Cache</a></li>\n<li><a href=\"#caching\">Caching</a></li>\n<li><a href=\"#%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">컴퓨터의 동작원리</a></li>\n<li><a href=\"#%EC%BA%90%EC%8B%9C-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\">캐시 동작 원리</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 14, 2022","title":"Cache와 Caching","categories":"개발지식","author":"JungSany","emoji":"🏦"},"fields":{"slug":"/cache-caching/"}},"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/left-inner-join/","nextSlug":"/sql-nosql/","prevSlug":"/cache-caching/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
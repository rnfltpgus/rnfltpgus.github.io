{"componentChunkName":"component---src-templates-blog-template-js","path":"/javascript/async-await/","result":{"data":{"cur":{"id":"e9e8326c-dd98-5bfa-b43f-c6f8b4e7750a","html":"<p><strong>Callback 지옥을 유발하는 처리방식보다 비동기 프로그래밍을 동기방식처럼 직관적으로 표현할 수 있다.</strong></p>\n<br/>\n<h2 id=\"async--await란\" style=\"position:relative;\"><a href=\"#async--await%EB%9E%80\" aria-label=\"async  await란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Async &#x26; await란?</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">Async</code>를 함수(Function) 앞에 붙이면 항상 promise를 반환한다.</p>\n<p>(프라미스가 아닌 값을 반환하더라도 이행 상태의 프라미스(resolved promise)로 값을 감싸 이행된 프라미스가 반환되도록 함)</p>\n</li>\n<li>\n<p><code class=\"language-text\">Async</code>는 평범한 함수를 프라미스를 리턴하는 비동기적인 함수로 만들어주는 키워드고</p>\n</li>\n<li>\n<p><code class=\"language-text\">Async 함수</code> 안에서 <code class=\"language-text\">await</code>는 코드의 순서를 기다리며 자신의 차례가 올때까지 기다렸다가 자신의 차례가 오면 결과를 반환한다.</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'완료!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> promise<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 프라미스가 이행될 때까지 치례를 기다림 (*)</span>\n\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"완료!\"</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3 id=\"async--await-이전에-promise를-사용할-경우\" style=\"position:relative;\"><a href=\"#async--await-%EC%9D%B4%EC%A0%84%EC%97%90-promise%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EA%B2%BD%EC%9A%B0\" aria-label=\"async  await 이전에 promise를 사용할 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Async &#x26; await 이전에 Promise를 사용할 경우</h3>\n<ul>\n<li>promise는 접근할때 .then()을 사용하고 error처리는 .catch()로 한다.</li>\n<li>단어의 의미 약속 ‘미래’ 시점의 데이터를 위한 것이긴 하지만 ‘promise’를 갖고 있기만 하면, 그 데이터가 미래시점에 있는지?, 이미 받았는지? 에 대해서는 상관없다.</li>\n<li>프로미스는 일관된 비동기를 강제한다.</li>\n</ul>\n<br/>\n<h3 id=\"promise와-async--await-차이\" style=\"position:relative;\"><a href=\"#promise%EC%99%80-async--await-%EC%B0%A8%EC%9D%B4\" aria-label=\"promise와 async  await 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise와 Async &#x26; await 차이</h3>\n<ul>\n<li>프로미스 .then()과 await는 쓰는 방법이 거의 똑같다. <code class=\"language-text\">다른 점이 있다면 콜백함수를 요구하지 않는다는 점은 다르다.</code></li>\n</ul>\n<br/>\n<h3 id=\"알아볼것\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EC%95%84%EB%B3%BC%EA%B2%83\" aria-label=\"알아볼것 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알아볼것</h3>\n<ul>\n<li>이전에 나온것이지만 최근에 async를 사용하지 않아도 await만으로 작성이 가능하다는 글을 보았는데, 찾아봐아겠다.</li>\n</ul>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://ko.javascript.info/async-await\">async await란?</a></p>\n<p><a href=\"https://medium.com/@la.place/async-await%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94%EA%B0%80-fa08a3157647\">Async-await는 어떻게 구현하는가</a></p>\n<p><a href=\"https://kiwanjung.medium.com/%EB%B2%88%EC%97%AD-async-await-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90-promise%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-955dbac2c4a4\">[번역] async/await 를 사용하기 전에 promise를 이해하기</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#async--await%EB%9E%80\">Async &#x26; await란?</a></p>\n<ul>\n<li><a href=\"#async--await-%EC%9D%B4%EC%A0%84%EC%97%90-promise%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EA%B2%BD%EC%9A%B0\">Async &#x26; await 이전에 Promise를 사용할 경우</a></li>\n<li><a href=\"#promise%EC%99%80-async--await-%EC%B0%A8%EC%9D%B4\">Promise와 Async &#x26; await 차이</a></li>\n<li><a href=\"#%EC%95%8C%EC%95%84%EB%B3%BC%EA%B2%83\">알아볼것</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"Callback 지옥을 유발하는 처리방식보다 비동기 프로그래밍을 동기방식처럼 직관적으로 표현할 수 있다. Async & await란? 를 함수(Function) 앞에 붙이면 항상 promise를 반환한다. (프라미스가 아닌 값을 반환하더라도 이행 상태의 프라미스(resolved promise)로 값을 감싸 이행된 프라미스가 반환되도록 함) 는 평범한 함수를 프라미스를 리턴하는 비동기적인 함수로 만들어주는 키워드고  안에서 는 코드의 순서를 기다리며 자신의 차례가 올때까지 기다렸다가 자신의 차례가 오면 결과를 반환한다. Async & await 이전에 Promise를 사용할 경우 promise는 접근할때 .then()을 사용하고 error처리는 .catch()로 한다. 단어의 의미 약속 ‘미래’ 시점의 데이터를 위한 것이긴 하지만 ‘promise’를 갖고 있기만 하면, 그 데이터가 미래시점에 있는지?, 이미 받았는지? 에 대해서는 상관없다. 프로미스는 일관된 비동기를 강제한다. Pr…","frontmatter":{"date":"December 21, 2022","title":"Async & await","categories":"JavaScript","author":"JungSany","emoji":"🍈"},"fields":{"slug":"/javascript/async-await/"}},"next":{"id":"13ee77c5-f84a-5296-8837-5e8b77b99fad","html":"<h3 id=\"promise란\" style=\"position:relative;\"><a href=\"#promise%EB%9E%80\" aria-label=\"promise란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise란?</h3>\n<ul>\n<li>“<strong><em><code class=\"language-text\">Promise</code>란 비동기 처리를 조금 더 수월하게 처리하게끔 도와주는 추상화된 소프트웨어 개념”</em></strong></li>\n<li>콜백지옥을 해결하기 위해 <code class=\"language-text\">ES6</code>에서 Promise로 지원하게 되었다.</li>\n<li><strong>Promise의 핵심은 비동기에서 성공과 실패를 분리해서 메소드를 수행하며, <code class=\"language-text\">에러핸들링이 가능</code>하다는 점이 있다.</strong></li>\n<li>Promise는 <code class=\"language-text\">두가지 인수를 받는데</code>, 비동기식이 정상적으로 실행된다면 <code class=\"language-text\">resolve</code>를 비정상적으로 실행된다면 두번째 인수인 <code class=\"language-text\">reject</code>를 호출한다.</li>\n</ul>\n<br/>\n<h3 id=\"promise를-호출한-이유-사용할-수-있는-메소드는-code-classlanguage-text3가지code\" style=\"position:relative;\"><a href=\"#promise%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%9C-%EC%9D%B4%EC%9C%A0-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%A9%94%EC%86%8C%EB%93%9C%EB%8A%94-code-classlanguage-text3%EA%B0%80%EC%A7%80code\" aria-label=\"promise를 호출한 이유 사용할 수 있는 메소드는 code classlanguage text3가지code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise를 호출한 이유 사용할 수 있는 메소드는 <code class=\"language-text\">3가지</code></h3>\n<ul>\n<li>then: reslove()를 통한 리턴 값</li>\n<li>catch: reject()를 통한 리턴 값</li>\n<li>finally: 실행 여부와 상관없이 이후 이벤트 실행</li>\n</ul>\n<br/>\n<h3 id=\"가장-큰-code-classlanguage-text장점code으로는\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%9E%A5-%ED%81%B0-code-classlanguage-text%EC%9E%A5%EC%A0%90code%EC%9C%BC%EB%A1%9C%EB%8A%94\" aria-label=\"가장 큰 code classlanguage text장점code으로는 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가장 큰 <code class=\"language-text\">장점</code>으로는</h3>\n<ul>\n<li>코드의 가독성이 증가</li>\n<li>반복해서 재사용하는 예외처리 작업이 줄어듬</li>\n<li><code class=\"language-text\">throw</code>를 사용하면 <code class=\"language-text\">error</code> 상황을 쉽게 찾아내 <code class=\"language-text\">에러 핸들링이 한결 편해짐</code></li>\n</ul>\n<br/>\n<h3 id=\"한번에-비동기-처리를-해야되는-경우\" style=\"position:relative;\"><a href=\"#%ED%95%9C%EB%B2%88%EC%97%90-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EB%A5%BC-%ED%95%B4%EC%95%BC%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"한번에 비동기 처리를 해야되는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>한번에 비동기 처리를 해야되는 경우</h3>\n<ul>\n<li><strong>Promise.all</strong>\n<ul>\n<li>프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받는다. 그리고 <code class=\"language-text\">전달받은 모든 프로미스를 병렬로 처리</code>하고 그 처리 결과를 resolve하는 새로운 프로미스를 반환한다.</li>\n<li><strong>전달받은 모든 프로미스를 병렬로 처리</strong>한다. 이때 모든 프로미스의 처리가 종료될 때까지 기다린 후 모든 처리 결과를 resolve 또는 reject 한다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 1</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 2</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 3</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span> <span class=\"token comment\">// [ 1, 2, 3 ]</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span>console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - JavaScript | MDN</a></p>\n<p><a href=\"https://velog.io/@beberiche/promise-asyncawait\">promise, async/await</a></p>\n<p><a href=\"https://ko.javascript.info/promise-basics\">프라미스</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#promise%EB%9E%80\">Promise란?</a></li>\n<li><a href=\"#promise%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%9C-%EC%9D%B4%EC%9C%A0-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%A9%94%EC%86%8C%EB%93%9C%EB%8A%94-3%EA%B0%80%EC%A7%80\">Promise를 호출한 이유 사용할 수 있는 메소드는 <code class=\"language-text\">3가지</code></a></li>\n<li><a href=\"#%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%9E%A5%EC%A0%90%EC%9C%BC%EB%A1%9C%EB%8A%94\">가장 큰 <code class=\"language-text\">장점</code>으로는</a></li>\n<li><a href=\"#%ED%95%9C%EB%B2%88%EC%97%90-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EB%A5%BC-%ED%95%B4%EC%95%BC%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\">한번에 비동기 처리를 해야되는 경우</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 21, 2022","title":"Promise","categories":"JavaScript","author":"JungSany","emoji":"🍍"},"fields":{"slug":"/javascript/promise/"}},"prev":{"id":"8bbd5eee-deab-5763-ab73-93928f3656c2","html":"<h2 id=\"ssr-server-side-rendring\" style=\"position:relative;\"><a href=\"#ssr-server-side-rendring\" aria-label=\"ssr server side rendring permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSR (Server Side Rendring)</h2>\n<p><strong>서버로 부터 완전하게 만들어진 html파일을 받아와 페이지 전체를 렌더링 하는 방식이다.</strong></p>\n<br/>\n<h3 id=\"11-과정\" style=\"position:relative;\"><a href=\"#11-%EA%B3%BC%EC%A0%95\" aria-label=\"11 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1 과정</h3>\n<ul>\n<li>유저가 웹사이트에 요청을 보낸다.</li>\n<li>서버는 필요하다면 데이터베이스에서 데이터를 가지고 오고, 페이지를 렌더링하는데 필요한 작업을 수행한 HTML 파일을 만든다.</li>\n<li>유저는 이제 서버가 렌더링 해준 HTML을 이용하여 콘텐츠를 볼 수 있다. (<strong>Time to view</strong>)</li>\n<li>하지만 아직 페이지에서 상호작용을 할 수 있는 JS파일이 존재하지 않기 때문에 페이지에서 클릭했을 때 반응이 일어나지 않는 부분이 존재한다.</li>\n<li>브라우저에서 필요한 상호작용에 필요한 JS 파일을 서버로 부터 받는다.</li>\n<li>JS 파일을 브라우저에서 컴파일 후 인터랙티브한 페이지가 완성된다. <strong>(Time To Interact)</strong></li>\n</ul>\n<p><img src=\"https://miro.medium.com/max/1400/1*VG33xLBOqcpfctgiyh0jtA.webp\" alt=\"ssr\"></p>\n<br/>\n<h3 id=\"12-장점\" style=\"position:relative;\"><a href=\"#12-%EC%9E%A5%EC%A0%90\" aria-label=\"12 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2 장점</h3>\n<ul>\n<li>HTML 컨텐츠가 이미 담겨져 있기에 **SEO(Search Engine Optimizaion)**에 좋다.</li>\n<li>사용자에게 <strong>첫 콘텐츠를 빨리 보여줄 수 있는 장점</strong>이 존재한다.</li>\n</ul>\n<br/>\n<h3 id=\"13-단점\" style=\"position:relative;\"><a href=\"#13-%EB%8B%A8%EC%A0%90\" aria-label=\"13 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3 단점</h3>\n<ul>\n<li><strong>매번 페이지를 요청할 때마다 새로고침 되는 치명적인 단점이 존재한다.</strong></li>\n<li>TTV(Time To View)와 TTI(Time To Interact)의 공백이 발생한다.</li>\n<li>페이지를 구성하는 모든 리소스를 서버에서 처리하므로 요청이 많아질 때 <strong>서버 부담이 증가한다.</strong></li>\n</ul>\n<p><strong>중요한 부분은 렌더링 주체가 ‘서버’ 라는 점이다.</strong></p>\n<br/>\n<h2 id=\"csr-client-side-rendring\" style=\"position:relative;\"><a href=\"#csr-client-side-rendring\" aria-label=\"csr client side rendring permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSR (Client Side rendring)</h2>\n<p><strong>CSR은 페이지를 브라우저에서 서버로 부터 받은 JS 파일을 이용하여 직접 렌더링 하는 것을 의미한다. (이는 페이지 전환이 이루어지는 것이 아닌 변경이 필요한 부분만 바뀌므로 <code class=\"language-text\">화면이 부드럽게 동작하여 사용자 입장에서는 보기 더 편한 느낌</code>을 준다.)</strong></p>\n<br/>\n<h3 id=\"21-과정\" style=\"position:relative;\"><a href=\"#21-%EA%B3%BC%EC%A0%95\" aria-label=\"21 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1 과정</h3>\n<ul>\n<li>유저가 웹사이트에 요청을 보낸다.</li>\n<li>브라우저는 링크를 이용하여 화면을 그리는데 필요한 HTML, JS 파일을 다운받는다.</li>\n<li>브라우저는 JS 코드를 실행하여 리액트를 구동한다.</li>\n<li>이 때 API를 통해 데이터베이스에 존재하는 데이터를 사용할 경우 API를 호출한다.</li>\n<li>서버에서 데이터베이스에서 조회한 데이터를 응답한다.</li>\n<li>API로 부터 받은 데이터를 채워준 뒤 리액트가 VirtualDOM에 콘텐츠를 렌더링 한다.</li>\n<li>VirtualDOM이 구성이 완료되면 이를 브라우저 DOM 붙힌다.</li>\n</ul>\n<p><img src=\"https://miro.medium.com/max/1400/1*cRftPL0mxSxiVSg-E0P7IA.webp\" alt=\"csr\"></p>\n<br/>\n<h3 id=\"22-장점\" style=\"position:relative;\"><a href=\"#22-%EC%9E%A5%EC%A0%90\" aria-label=\"22 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2 장점</h3>\n<ul>\n<li>렌더링이 필요한 부분만 바꾸기 때문에 페이지 새로고침이 발생하지 않는다.</li>\n<li>렌더링 주체가 브라우저 이므로 서버에 부하를 줄일 수 있다.</li>\n</ul>\n<br/>\n<h3 id=\"23-단점\" style=\"position:relative;\"><a href=\"#23-%EB%8B%A8%EC%A0%90\" aria-label=\"23 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3 단점</h3>\n<ul>\n<li><strong>JS 파일을 번들링</strong>해서 한번에 받기 때문에 초기 유저가 콘텐츠를 보기까지의 속도가 느리다.</li>\n<li>기본 HTML이 비어있어 <code class=\"language-text\">SEO(Search Engine Optimizaion)</code>에 최적화 되어 있지 않다.</li>\n</ul>\n<p><strong>중요한 부분은 렌더링 주체가 ‘브라우저’ 라는 점이다.</strong></p>\n<br/>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p><strong>페이지 이동이 많고 유저와 상호작용이 많은 넷플릭스의 경우 CSR을 적극적으로 활용하고, 페이지 이동이 적고 SEO를 최적하여 검색 결과 상위에 위치해야 하는 회사 홈페이지의 경우 SSR이 적절할 것으로 보인다.</strong></p>\n<p><strong>서비스의 성격</strong>에 따라 적절한 방식을 채용하고, 또 필요에 따라서 <strong>두가지를 섞는 방법</strong>도 고려해야 할 것 같다.</p>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://towardsdev.com/server-side-rendering-srr-in-javascript-a1b7298f0d04\">A Deep Dive into Server-Side Rendering (SSR) in JavaScript</a></p>\n<p><a href=\"https://web.dev/rendering-on-the-web/\">Rendering on the Web</a></p>\n<p><a href=\"https://yeoossi.tistory.com/40\">여씨의 개발이야기</a></p>\n<p><a href=\"https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8\">The Benefits of Server Side Rendering Over Client Side Rendering</a></p>\n<p><a href=\"https://d2.naver.com/helloworld/7804182\"></a></p>\n<p><a href=\"https://ajdkfl6445.gitbook.io/study/web/csr-vs-ssr-vs-ssg#static-site-generator-ssg\">CSR vs SSR vs SSG</a></p>\n<p><a href=\"https://velog.io/@yu2jeong/TTV-Time-To-View-TTI-Time-To-Interact\">TTV (Time To View) &#x26; TTI (Time To Interact)</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#ssr-server-side-rendring\">SSR (Server Side Rendring)</a></p>\n<ul>\n<li><a href=\"#11-%EA%B3%BC%EC%A0%95\">1.1 과정</a></li>\n<li><a href=\"#12-%EC%9E%A5%EC%A0%90\">1.2 장점</a></li>\n<li><a href=\"#13-%EB%8B%A8%EC%A0%90\">1.3 단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#csr-client-side-rendring\">CSR (Client Side rendring)</a></p>\n<ul>\n<li><a href=\"#21-%EA%B3%BC%EC%A0%95\">2.1 과정</a></li>\n<li><a href=\"#22-%EC%9E%A5%EC%A0%90\">2.2 장점</a></li>\n<li><a href=\"#23-%EB%8B%A8%EC%A0%90\">2.3 단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 21, 2022","title":"CSR vs SSR 특징 및 차이","categories":"개발지식","author":"JungSany","emoji":"🌏"},"fields":{"slug":"/knowledge/ssr-csr/"}},"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/javascript/async-await/","nextSlug":"/javascript/promise/","prevSlug":"/knowledge/ssr-csr/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
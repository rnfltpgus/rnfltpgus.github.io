{"componentChunkName":"component---src-templates-blog-template-js","path":"/javascript/closure/","result":{"data":{"cur":{"id":"abaf6c36-08f0-5bba-b7a9-2deeb2caeaa4","html":"<p>함수와 함수가 선언된 어휘적 환경의 조합이다.</p>\n<br/>\n<h2 id=\"어휘적-범위-지정lexical-scoping\" style=\"position:relative;\"><a href=\"#%EC%96%B4%ED%9C%98%EC%A0%81-%EB%B2%94%EC%9C%84-%EC%A7%80%EC%A0%95lexical-scoping\" aria-label=\"어휘적 범위 지정lexical scoping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어휘적 범위 지정(Lexical scoping)</h2>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Sanny'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// name은 init에 의해 생성된 지역 변수이다.</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">displayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// displayName() 은 내부 함수이며, 클로저다.</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 부모 함수에서 선언된 변수를 사용한다.</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">displayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>위 코드를 실행하면 <code class=\"language-text\">displayName()</code> 함수 내의 <code class=\"language-text\">alert()</code>문이 부모 함수에서 정의한 변수 <code class=\"language-text\">name</code>의 값을 성공적으로 출력한다.</li>\n<li>이 예시를 통해 함수가 <code class=\"language-text\">중첩된 상황</code>에서 파서가 어떻게 변수를 처리하는지 알 수 있다.</li>\n<li>이는 어휘적 범위 지정(Lexical Scoping)의 한 예이다. 여기서 <code class=\"language-text\">Lexical</code>이란, 어휘적 범위 지정(Lexical Scoping) 과정에서 변수가 어디에서 사용 가능한지 알기 위해 그 변수가 소스코드 내 어디에서 선언되었는지 고려한다는 것을 의미한다.</li>\n<li>단어 <code class=\"language-text\">Lexical</code>은 이런 사실을 나타낸다. <code class=\"language-text\">중첩된 함수</code>는 외부 범위(scope)에서 선언한 변수에도 접근할 수 있다.</li>\n</ul>\n<br/>\n<h2 id=\"클로저closure\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\" aria-label=\"클로저closure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저(Closure)</h2>\n<ul>\n<li>자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성한다.</li>\n<li>클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다.</li>\n<li><code class=\"language-text\">클로저(Closure)</code>는 <strong>내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것</strong>을 말한다.</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%96%B4%ED%9C%98%EC%A0%81-%EB%B2%94%EC%9C%84-%EC%A7%80%EC%A0%95lexical-scoping\">어휘적 범위 지정(Lexical scoping)</a></li>\n<li><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\">클로저(Closure)</a></li>\n</ul>\n</div>","excerpt":"함수와 함수가 선언된 어휘적 환경의 조합이다. 어휘적 범위 지정(Lexical scoping) 위 코드를 실행하면  함수 내의 문이 부모 함수에서 정의한 변수 의 값을 성공적으로 출력한다. 이 예시를 통해 함수가 에서 파서가 어떻게 변수를 처리하는지 알 수 있다. 이는 어휘적 범위 지정(Lexical Scoping)의 한 예이다. 여기서 이란, 어휘적 범위 지정(Lexical Scoping) 과정에서 변수가 어디에서 사용 가능한지 알기 위해 그 변수가 소스코드 내 어디에서 선언되었는지 고려한다는 것을 의미한다. 단어 은 이런 사실을 나타낸다. 는 외부 범위(scope)에서 선언한 변수에도 접근할 수 있다. 클로저(Closure) 자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성한다. 클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다. 는 내부함수가 외부함수의 맥락(context)에 …","frontmatter":{"date":"December 23, 2022","title":"클로저(Closure)란?","categories":"JavaScript","author":"JungSany","emoji":"📎"},"fields":{"slug":"/javascript/closure/"}},"next":{"id":"3671c8f8-1687-5f94-84e7-a892b6f706b0","html":"<h2 id=\"리액트의-상태-업데이트는-항상-code-classlanguage-text불변적code으로-수행되어야-한다\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8A%94-%ED%95%AD%EC%83%81-code-classlanguage-text%EB%B6%88%EB%B3%80%EC%A0%81code%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"리액트의 상태 업데이트는 항상 code classlanguage text불변적code으로 수행되어야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트의 상태 업데이트는 항상 <code class=\"language-text\">불변적</code>으로 수행되어야 한다.</h2>\n<ul>\n<li><strong>mutate(돌연변이한)한 값의 대상과 위치에 따라 컴포넌트가 렌더링 되지 않을 수 있다.</strong></li>\n<li><strong>데이터가 실제로 업데이트 된 시기와 이유에 대해 혼란을 겪을 수 있다.</strong></li>\n</ul>\n<br/>\n<h2 id=\"불변성이란\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\" aria-label=\"불변성이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변성이란?</h2>\n<ul>\n<li><strong>Immutability(불변성)는 상태나 값을 변경하지 않는 것이다.</strong></li>\n<li>JavaScript에서 예를 들자면,\n<ul>\n<li>JavaScript의 원시 타입의 값들은 <code class=\"language-text\">불변성</code>을 갖고 있다.\n<ul>\n<li><strong>데이터 타입</strong>\n<ul>\n<li><strong>원시 타입(string, number, bigint, boolean, undefined, ES6 부터 추가된 symbol)</strong>\n<ul>\n<li>변경이 불가능한 값(읽기전용)</li>\n<li>원시 값을 변수에 할당하면 확보된 메모리 공간(주소)에는 실제 값이 저장됨</li>\n<li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다.</li>\n</ul>\n</li>\n<li><strong>참조 타입(Object, Array, Function)</strong>\n<ul>\n<li>변경이 가능한 값</li>\n<li>객체를 변수에 할당하면 확보된 메모리 공간에 참조값이 저장됨</li>\n<li>객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>즉, 원시타입은 재할당을 통해서만 변수에 저장한 값을 변경할 수 있지만, 객체타입은 재할당 없이 객체를 직접 동적으로 추가, 삭제 갱신 등이 가능하다는 것이 큰 차이점이다.</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"추가로-javascript에서-얕은-복사와-깊은-복사\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EB%A1%9C-javascript%EC%97%90%EC%84%9C-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"추가로 javascript에서 얕은 복사와 깊은 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가로 JavaScript에서 얕은 복사와 깊은 복사</h3>\n<ul>\n<li>얕은 복사(Shallow copy)\n<ul>\n<li>객체를 프로퍼티 값으로 갖는 객체의 경우에 한 단계 까지만 복사하는 것을 말한다.</li>\n<li>즉, 첫 객체는 새로운 메모리 주소를 가지지만 내부에 있는 중첩된 객체는 얕은 복사를 한 경우에 같은 메모리 주소를 가진다는 의미가 된다.</li>\n<li><strong>얕은 복사 방법으로는 <code class=\"language-text\">Object.assign()</code>, <code class=\"language-text\">전개연산자(spread)</code></strong></li>\n<li><strong>얕은 복사는 하위 중첩되어 있는 객체까지 복사하지 않으므로 공유에 의한 예기치 못한 결과를 얻을 수 있다.</strong></li>\n</ul>\n</li>\n<li>깊은 복사(Deep copy)\n<ul>\n<li><strong>하위에 중첩되어 있는 객체(배열 등)까지 모두 복사하는 것을 말함</strong></li>\n<li>즉, 원시 값처럼 완전히 새로운 메모리 공간을 차지하는 원시값처럼 복사본을 만든다.</li>\n<li><strong>깊은 복사 방법으로는 <code class=\"language-text\">JSON.stringify()</code>, <code class=\"language-text\">재귀함수</code>, <code class=\"language-text\">lodash의 cloneDeep</code></strong></li>\n</ul>\n</li>\n<li><strong>결론으로 객체의 참조 특성으로 인해 복사하고자 하는 객체에 중첩된 객체타입이 있는지를 확인하고 그에 맞는 복사 방법을 사용해야 한다.</strong></li>\n</ul>\n<br/>\n<h2 id=\"그래서-리액트-상태를-변경할-때-불변성을-지켜주어야-되는-이유\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%A0-%EB%95%8C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%A3%BC%EC%96%B4%EC%95%BC-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"그래서 리액트 상태를 변경할 때 불변성을 지켜주어야 되는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래서 리액트 상태를 변경할 때 불변성을 지켜주어야 되는 이유?</h2>\n<ul>\n<li>리액트에서 <code class=\"language-text\">불변성을 지켜주어야 되는 이유</code>는 리액트가 상태 업데이트를 하는 원리 때문이다.</li>\n<li>리액트는 상태 값을 업데이트 할 때 <code class=\"language-text\">얕은 비교</code>로 <strong>상태 변경 여부</strong>를 체크하며, 수행한다.</li>\n<li>즉, <code class=\"language-text\">리액트는</code> 객체의 속성 <strong>하나하나를 비교</strong>하는게 아니라 <code class=\"language-text\">참조 값만 비교하여 상태 변화를 감지</code>한다.</li>\n<li>이런 이유로 리엑트는 state(배열이나 객체)를 <code class=\"language-text\">업데이트 할 때 setState()를 사용</code>하여 <code class=\"language-text\">배열</code>이나 <code class=\"language-text\">객체를 새로 생성</code>해 새로운 참조 값을 만들어 <code class=\"language-text\">상태를 업데이트</code> 한다.</li>\n<li>그리고 리엑트에서 불변성을 지켜주면 다른 이점으로 <code class=\"language-text\">사이드 이펙트를 방지</code>할 수 있다.</li>\n</ul>\n<br/>\n<h3 id=\"정리하자면\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC%ED%95%98%EC%9E%90%EB%A9%B4\" aria-label=\"정리하자면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리하자면</h3>\n<p><strong>리액트는 불변성을 지켜주면 <code class=\"language-text\">효과적인 상태 업데이트(얕은 비교 수행: 계산 리소스를 줄여줌)</code>와 <code class=\"language-text\">사이드 이펙트를 방지하는 이점(원본 데이터를 건들게 될 경우, 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류가 발생할 수 있으며, 프로그래밍의 복잡도가 올라간다.)</code>을 가질 수 있게 된다.</strong></p>\n<br/>\n<h2 id=\"불변성을-지키며-상태를-업데이트-하는-방법은\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B0-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80\" aria-label=\"불변성을 지키며 상태를 업데이트 하는 방법은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변성을 지키며 상태를 업데이트 하는 방법은?</h2>\n<ul>\n<li>\n<p>spread operator, map, filter, slice, reduce 등등 <code class=\"language-text\">새로운 배열을 반환하는 메소드들을 활용</code>하거나</p>\n<ul>\n<li>splice는 원본데이터를 변경하기 때문에 사용하면 안된다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">setState를 이용</code>할 경우</p>\n<ul>\n<li><strong>원시타입인</strong> 경우에는 값을 바로 넣어서 사용해도 되지만</li>\n<li><strong>참조타입인</strong> 경우에는 새로운 객체나 배열을 생성한 후 값을 넣어주어야 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 원시타입</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>number<span class=\"token punctuation\">,</span> setNumber<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 참조타입</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>person<span class=\"token punctuation\">,</span> setPerson<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">33</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>person<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'seahyun'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<br/>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<ul>\n<li><strong>불변성이란</strong> 메모리 영역의 값을 변경하지 않는 것이다.</li>\n<li>리액트는 불변성을 지켜줌으로써 <code class=\"language-text\">효율적인 상태업데이트</code>를 한다.</li>\n<li>리액트는 불변성을 지켜줌으로써 <code class=\"language-text\">사이드 이펙트를 사전 방지하고 프로그래밍의 구조를 단순하게 유지</code>한다.</li>\n<li><strong>불변성을 가진 원시타입과 달리 <code class=\"language-text\">참조타입의 경우에는 의도적으로 불변성을 지켜주어야</code> 한다.</strong>\n<ul>\n<li><code class=\"language-text\">방법으로는</code> <strong>새로운 주소 값을 가진 객체(배열)를 생성하여 상태를 업데이트 해주어야 한다.</strong> 또는 <strong>spread operator, map, filter, slice, reduce 메소드들을 이용하여 새로운 배열의 값을 반환하여 사용</strong>한다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://ko.reactjs.org/tutorial/tutorial.html\">자습서: React 시작하기 - React</a></p>\n<p><a href=\"https://yceffort.kr/2022/04/deep-dive-in-react-rendering\">리액트의 렌더링은 어떻게 일어나는가?</a></p>\n<p><a href=\"https://velog.io/@nomadhash/Java-Script-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC\">[Java Script] 원시타입과 참조타입 👀</a></p>\n<p><a href=\"https://hsp0418.tistory.com/171\">리액트 불변성이란 무엇이고, 왜 지켜야 할까?</a></p>\n<p><a href=\"https://velog.io/@jma1020/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\">리액트에서 불변성이란</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8A%94-%ED%95%AD%EC%83%81-%EB%B6%88%EB%B3%80%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\">리액트의 상태 업데이트는 항상 <code class=\"language-text\">불변적</code>으로 수행되어야 한다.</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\">불변성이란?</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EA%B0%80%EB%A1%9C-javascript%EC%97%90%EC%84%9C-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\">추가로 JavaScript에서 얕은 복사와 깊은 복사</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%A0-%EB%95%8C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%A3%BC%EC%96%B4%EC%95%BC-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">그래서 리액트 상태를 변경할 때 불변성을 지켜주어야 되는 이유?</a></p>\n<ul>\n<li><a href=\"#%EC%A0%95%EB%A6%AC%ED%95%98%EC%9E%90%EB%A9%B4\">정리하자면</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B0-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80\">불변성을 지키며 상태를 업데이트 하는 방법은?</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 22, 2022","title":"React는 왜 불변성을 유지해야되나?","categories":"개발지식 React JavaScript","author":"JungSany","emoji":"💥"},"fields":{"slug":"/react/react-immutability/"}},"prev":{"id":"a6b9568c-df86-5095-bc7e-40b769a32a52","html":"<p><img src=\"https://cdn.filestackcontent.com/ApNH7030SAG1wAycdj3H\" alt=\"리엑트 라이프사이클 도표\"></p>\n<h1 id=\"life-cycle이란\" style=\"position:relative;\"><a href=\"#life-cycle%EC%9D%B4%EB%9E%80\" aria-label=\"life cycle이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life Cycle이란?</h1>\n<ul>\n<li>\n<p><code class=\"language-text\">컴포넌트의 수명</code>은 페이지에 렌더링 되기 전인 <strong>준비과정</strong>에서 시작하여, <strong>브라우저에 렌더링 및 업데이트</strong> 후 페이지에서 <strong>사라질 때</strong> 끝난다.</p>\n</li>\n<li>\n<p>컴포넌트는 <code class=\"language-text\">생성(mountion) → 업데이트(updating) → 제거(unmountion)의 생명주기</code>를 같는다.</p>\n</li>\n<li>\n<p><strong>클래스 컴포넌트</strong>는 라이플 사이클 메서드를 사용하고, <strong>함수형 컴포넌트</strong>는 Hook을 사용한다.</p>\n<p>(라이프사이클 메소드는 <strong>클래스 컴포넌트에서만 사용</strong>. 함수형 컴포넌트 → Hooks 사용)</p>\n</li>\n<li>\n<p>컴포넌트가 처음 렌더링 될 때, 어떤 작업을 처리해야하거나 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 수 도 있고, 불필요한 업데이트를 방지해야 할 수도 있다. 이러한 경우에 컴포넌트 <strong>라이프사이클 메소드를 사용</strong>한다.</p>\n</li>\n</ul>\n<br/>\n<h1 id=\"life-cycle의-구성\" style=\"position:relative;\"><a href=\"#life-cycle%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"life cycle의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life Cycle의 구성</h1>\n<ul>\n<li>\n<p>라이프 사이클은 총 3가지 카테고리로 구성 - <strong>Mount</strong>, <strong>Update</strong>, <strong>Unmount</strong></p>\n</li>\n<li>\n<p><code class=\"language-text\">will</code> 접두사 메소드 → 어떤 작업을 <strong>작동하기 전</strong>에 실행</p>\n</li>\n<li>\n<p><code class=\"language-text\">Did</code> 접두사 메소드 → 어떤 작업을 <strong>작동한 후</strong>에 실행</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"클래스-컴포넌트의-life-cycle\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-life-cycle\" aria-label=\"클래스 컴포넌트의 life cycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 컴포넌트의 Life Cycle</h2>\n<h3 id=\"mount\" style=\"position:relative;\"><a href=\"#mount\" aria-label=\"mount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mount</h3>\n<ul>\n<li>constructor : 컴포넌트의 생성자 메소드. <code class=\"language-text\">컴포넌트가 만들어지면 가장 먼저 실행</code>됨.</li>\n<li>getDerivedStateFromProps : <code class=\"language-text\">props로 받아온 것을 state에 넣어주고 싶을 때 사용</code>.</li>\n<li>render : <code class=\"language-text\">컴포넌트를 렌더링하는 메소드</code></li>\n<li>componentDidMount : <code class=\"language-text\">컴포넌트의 첫번째 렌더링이 끝나면 호출되는 메소드</code>. 이 메소드가 호출되는 시점에서 우리가 만든 컴포넌트가 화면에 나타난 상태. (여기서 주로 D3, masonry 처럼 DOM을 사용해야하는 외부 라이브러리 연동을 하거나, 해당 컴포넌트에서 필요로하는 데이터를 요청하기 위해 axios, fetch 등을 이용하여 ajax 요청을 하거나, DOM의 속성을 읽거나 직접 변경하는 작업을 진행)</li>\n</ul>\n<br/>\n<h3 id=\"update\" style=\"position:relative;\"><a href=\"#update\" aria-label=\"update permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Update</h3>\n<ul>\n<li>getDerivedStateFromProps : <code class=\"language-text\">컴포넌트의 props나 state가 바뀌었을때도 이 메소드가 호출</code>됨.</li>\n<li>ShouldComponenetUpdate : <code class=\"language-text\">컴포넌트가 리렌더링 할지 말지를 결정</code></li>\n<li>render : mount와 상동</li>\n<li>getSnapshotBeforeUpdate : 컴포넌트에 변화가 일어나기 직전의 DOM 상태를 가져와서 특정 값을 반환하면, 그 다음 발생하게 되는 componentDidUpdate 함수에서 받아와서 사용할 수 있음.</li>\n<li>componentDidUpdate : <code class=\"language-text\">리렌더링을 마치고, 화면에 우리가 원하는 변화가 모드 반영되고 난 뒤 호출되는 메소드</code>. 3번째 파라미터로 getSnapshotBeforeUpdate에서 반환 값 조회 가능.</li>\n</ul>\n<br/>\n<h3 id=\"unmount\" style=\"position:relative;\"><a href=\"#unmount\" aria-label=\"unmount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unmount</h3>\n<ul>\n<li>componentWillUnmount : <code class=\"language-text\">컴포넌트가 화면에서 사라지기 직전에 호출</code></li>\n</ul>\n<br/>\n<h2 id=\"함수-컴포넌트의-life-cycle\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-life-cycle\" aria-label=\"함수 컴포넌트의 life cycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 컴포넌트의 Life Cycle</h2>\n<h3 id=\"hooks이-나온-이유와-이용-규칙\" style=\"position:relative;\"><a href=\"#hooks%EC%9D%B4-%EB%82%98%EC%98%A8-%EC%9D%B4%EC%9C%A0%EC%99%80-%EC%9D%B4%EC%9A%A9-%EA%B7%9C%EC%B9%99\" aria-label=\"hooks이 나온 이유와 이용 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hooks이 나온 이유와 이용 규칙</h3>\n<ul>\n<li>\n<p>기존의 클래스 문법에서 사용하였던 라이프사이클 메서드 기반은 <code class=\"language-text\">관련 없는 로직이 섞여 코드가 작성되는 경우가 있었고 그로 인해서 버그가 쉽게 발생하고, 무결성을 해치는 경우가 많았다.</code> 때문에 <code class=\"language-text\">로직 기반으로</code> 나눌 수 있고 컴포넌트를 함수 단위로 잘게 쪼갤 수 있는 <code class=\"language-text\">React Hooks</code>가 나와 함수 컴포넌트로 작성하게 되었다.</p>\n</li>\n<li>\n<p><strong>Hooks을 이용하기 위해서는</strong></p>\n<ul>\n<li><code class=\"language-text\">최상위</code>에서만 호출해야하며, <code class=\"language-text\">반복문・조건문・중첩된 함수</code> 내에서 Hook을 실행하면 안 된다.</li>\n</ul>\n</li>\n<li>\n<p>이 규칙을 따르면 컴포넌트가 렌더링될 때마다 동일한 순서로 호출되는 것을 보장할 수 있다.</p>\n</li>\n</ul>\n<br/>\n<h3 id=\"hooks의-종류와-사용법\" style=\"position:relative;\"><a href=\"#hooks%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"hooks의 종류와 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hooks의 종류와 사용법</h3>\n<h4 id=\"usestate\" style=\"position:relative;\"><a href=\"#usestate\" aria-label=\"usestate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useState</h4>\n<ul>\n<li>상태를 변수로 선언하여 관리하며, 상태의 불변성을 유지한 채 상태를 변경할 수 있도록 도와준다.</li>\n<li>[state, setState]의 인자로는\n<ul>\n<li>첫번째: 상태의 <code class=\"language-text\">현재 값이 표현</code>되고 초기에는 사용자가 제공한 초기 상태로 설정되어 표현된다.</li>\n<li>두번째: 상호 작용에 따라 다른 값으로 변경할 수 있는 <code class=\"language-text\">setState</code></li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h4 id=\"useeffect\" style=\"position:relative;\"><a href=\"#useeffect\" aria-label=\"useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect</h4>\n<ul>\n<li>외부 시스템과 동기화하기 위해 사용된다.</li>\n<li>화면에 렌더링이 완료된 후에 수행되며, componentDidMount와 componentDidUpdate, componentWillUnmount가 합쳐진 것으로</li>\n<li>Hook를 이용하여 Life Cycle을 설명할 수 있는 대표적인 Hooks이다.</li>\n<li>useEffect안에서의 return은 비동기 관련 로직을 정리하기 위에 clean-up를 사용하기위해 쓰여진다.</li>\n<li>메모리 누수 방지를 위해 UI에서 컴포넌트를 제거하기 전에 수행</li>\n<li>컴포넌트가 여러 번 렌더링 된다면 다음 effect가 수행되기 전에 이전 effect가 정리됩니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 렌더링 결과가 실제 돔에 반영된 후마다 호출</span>\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 컴포넌트가 처음 나타날때 한 번 호출</span>\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>의존성<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> 의존성<span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 조건부 effect 발생, 의존성 중 하나가 변경된다면, 리렌더링이 일어난다.</span></code></pre></div>\n<br/>\n<h4 id=\"usecontext\" style=\"position:relative;\"><a href=\"#usecontext\" aria-label=\"usecontext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useContext</h4>\n<ul>\n<li>Context API를 통해 만들어진 Context에서 제공하는 Value를 가져올 수 있다.</li>\n<li>컴포넌트에서 가장 가까운 &#x3C;MyContext.Provider>가 갱신되면 이 Hook은 그 MyContext provider에게 전달된 가장 최신의 context value를 사용하여 렌더러를 트리거 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> <span class=\"token function\">useContext</span><span class=\"token punctuation\">(</span>MyContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h4 id=\"usereducer\" style=\"position:relative;\"><a href=\"#usereducer\" aria-label=\"usereducer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useReducer</h4>\n<ul>\n<li>useState의 대체 함수로 컴포넌트 상태 업데이트 로직을 컴포넌트에서 분리시킬 수 있다.</li>\n<li>컴포넌트 바깥에 로직을 작성할 수 도 있고, 심지어 다른 파일에 작성한 후 불러와서 사용할 수도 있다.</li>\n<li>reducer란 현재 상태와 액션 객체를 파라미터로 받아와서 새로운 상태를 반환해주는 함수이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useReducer</span><span class=\"token punctuation\">(</span>reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h4 id=\"useref\" style=\"position:relative;\"><a href=\"#useref\" aria-label=\"useref permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useRef</h4>\n<ul>\n<li>특정 DOM 선택할때 주로 쓰이며 .current 프로퍼티로 전달된 인자로 초기화된 변경 가능한 ref 객체를 반환합니다.</li>\n<li>반환된 객체는 컴포넌트의 전 생애주기를 통해 유지됩니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> refContainer <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h4 id=\"usememo\" style=\"position:relative;\"><a href=\"#usememo\" aria-label=\"usememo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo</h4>\n<ul>\n<li>메모이제이션된 값을 반환한다.</li>\n<li>이미 연산 된 값을 리렌더링 시 다시 계산하지 않도록 한다.</li>\n<li>의존성이 변경되었을 때에만 메모이제이션된 값만 다시 계산한다.</li>\n<li>의존성 배열이 없는 경우 매 렌더링 때마다 새 값을 계산한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> memoizedValue <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">computeExpensiveValue</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h4 id=\"usecallback\" style=\"position:relative;\"><a href=\"#usecallback\" aria-label=\"usecallback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback</h4>\n<ul>\n<li>메모이제이션 된 콜백을 반환한다.</li>\n<li>useMemo와 유사하게 이용되며 ‘함수’에 적용해준다.</li>\n<li>의존성이 변경되었을때만 변경된다. 그렇기 때문에 특정 함수를 새로 만들지 않고 재사용가능하게 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> memoizedCallback <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h1 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h1>\n<p><a href=\"https://ko.reactjs.org/docs/react-component.html\">React.Component - React</a></p>\n<p><a href=\"https://beta.reactjs.org/apis/react\">react: Hooks</a></p>\n<p><a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">React Lifecycle Methods diagram</a></p>\n<p><a href=\"https://velog.io/@minbr0ther/React.js-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4life-cycle-%EC%88%9C%EC%84%9C-%EC%97%AD%ED%95%A0\">[React.js] 리액트 라이프사이클(life cycle) 순서, 역할, Hook</a></p>\n<p><a href=\"https://velog.io/@youngminss/React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EB%A9%94%EC%84%9C%EB%93%9C\">[React] 컴포넌트 생명주기 메서드</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-life-cycle\">클래스 컴포넌트의 Life Cycle</a></p>\n<ul>\n<li><a href=\"#mount\">Mount</a></li>\n<li><a href=\"#update\">Update</a></li>\n<li><a href=\"#unmount\">Unmount</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%95%A8%EC%88%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-life-cycle\">함수 컴포넌트의 Life Cycle</a></p>\n<ul>\n<li>\n<p><a href=\"#hooks%EC%9D%B4-%EB%82%98%EC%98%A8-%EC%9D%B4%EC%9C%A0%EC%99%80-%EC%9D%B4%EC%9A%A9-%EA%B7%9C%EC%B9%99\">Hooks이 나온 이유와 이용 규칙</a></p>\n</li>\n<li>\n<p><a href=\"#hooks%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EC%82%AC%EC%9A%A9%EB%B2%95\">Hooks의 종류와 사용법</a></p>\n<ul>\n<li><a href=\"#usestate\">useState</a></li>\n<li><a href=\"#useeffect\">useEffect</a></li>\n<li><a href=\"#usecontext\">useContext</a></li>\n<li><a href=\"#usereducer\">useReducer</a></li>\n<li><a href=\"#useref\">useRef</a></li>\n<li><a href=\"#usememo\">useMemo</a></li>\n<li><a href=\"#usecallback\">useCallback</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 23, 2022","title":"컴포넌트의 생명주기(Life Cycle)","categories":"React","author":"JungSany","emoji":"🏥"},"fields":{"slug":"/react/life-cycle/"}},"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/javascript/closure/","nextSlug":"/react/react-immutability/","prevSlug":"/react/life-cycle/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
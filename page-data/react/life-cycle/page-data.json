{"componentChunkName":"component---src-templates-blog-template-js","path":"/react/life-cycle/","result":{"data":{"cur":{"id":"a6b9568c-df86-5095-bc7e-40b769a32a52","html":"<h1 id=\"-보완예정\" style=\"position:relative;\"><a href=\"#-%EB%B3%B4%EC%99%84%EC%98%88%EC%A0%95\" aria-label=\" 보완예정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤯 보완예정</h1>\n<br/>\n<h1 id=\"life-cycle이란\" style=\"position:relative;\"><a href=\"#life-cycle%EC%9D%B4%EB%9E%80\" aria-label=\"life cycle이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life Cycle이란?</h1>\n<ul>\n<li>\n<p><code class=\"language-text\">컴포넌트의 수명</code>은 페이지에 렌더링 되기 전인 <strong>준비과정</strong>에서 시작하여, <strong>브라우저에 렌더링 및 업데이트</strong> 후 페이지에서 <strong>사라질 때</strong> 끝난다.</p>\n</li>\n<li>\n<p>컴포넌트는 <code class=\"language-text\">생성(mountion) → 업데이트(updating) → 제거(unmountion)의 생명주기</code>를 같는다.</p>\n</li>\n<li>\n<p><strong>클래스 컴포넌트</strong>는 라이플 사이클 메서드를 사용하고, <strong>함수형 컴포넌트</strong>는 Hook을 사용한다.</p>\n<p>(라이프사이클 메소드는 <strong>클래스 컴포넌트에서만 사용</strong>. 함수형 컴포넌트 → Hooks 사용)</p>\n</li>\n<li>\n<p>컴포넌트가 처음 렌더링 될 때, 어떤 작업을 처리해야하거나 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 수 도 있고, 불필요한 업데이트를 방지해야 할 수도 있다. 이러한 경우에 컴포넌트 <strong>라이프사이클 메소드를 사용</strong>한다.</p>\n</li>\n</ul>\n<br/>\n<h1 id=\"life-cycle의-구성\" style=\"position:relative;\"><a href=\"#life-cycle%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"life cycle의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life Cycle의 구성</h1>\n<ul>\n<li>\n<p>라이프 사이클은 총 3가지 카테고리로 구성 - <strong>Mount</strong>, <strong>Update</strong>, <strong>Unmount</strong></p>\n</li>\n<li>\n<p><code class=\"language-text\">will</code> 접두사 메소드 → 어떤 작업을 <strong>작동하기 전</strong>에 실행</p>\n</li>\n<li>\n<p><code class=\"language-text\">Did</code> 접두사 메소드 → 어떤 작업을 <strong>작동한 후</strong>에 실행</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"클래스-컴포넌트의-life-cycle\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-life-cycle\" aria-label=\"클래스 컴포넌트의 life cycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 컴포넌트의 Life Cycle</h2>\n<p><img src=\"https://cdn.filestackcontent.com/ApNH7030SAG1wAycdj3H\" alt=\"클래스 컴포넌트  Life Cycle\"></p>\n<h3 id=\"mount\" style=\"position:relative;\"><a href=\"#mount\" aria-label=\"mount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mount</h3>\n<ul>\n<li>constructor : 컴포넌트의 생성자 메소드. <code class=\"language-text\">컴포넌트가 만들어지면 가장 먼저 실행</code>됨.</li>\n<li>getDerivedStateFromProps : <code class=\"language-text\">props로 받아온 것을 state에 넣어주고 싶을 때 사용</code>.</li>\n<li>render : <code class=\"language-text\">컴포넌트를 렌더링하는 메소드</code></li>\n<li>componentDidMount : <code class=\"language-text\">컴포넌트의 첫번째 렌더링이 끝나면 호출되는 메소드</code>. 이 메소드가 호출되는 시점에서 우리가 만든 컴포넌트가 화면에 나타난 상태. (여기서 주로 D3, masonry 처럼 DOM을 사용해야하는 외부 라이브러리 연동을 하거나, 해당 컴포넌트에서 필요로하는 데이터를 요청하기 위해 axios, fetch 등을 이용하여 ajax 요청을 하거나, DOM의 속성을 읽거나 직접 변경하는 작업을 진행)</li>\n</ul>\n<br/>\n<h3 id=\"update\" style=\"position:relative;\"><a href=\"#update\" aria-label=\"update permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Update</h3>\n<ul>\n<li>getDerivedStateFromProps : <code class=\"language-text\">컴포넌트의 props나 state가 바뀌었을때도 이 메소드가 호출</code>됨.</li>\n<li>ShouldComponenetUpdate : <code class=\"language-text\">컴포넌트가 리렌더링 할지 말지를 결정</code></li>\n<li>render : mount와 상동</li>\n<li>getSnapshotBeforeUpdate : 컴포넌트에 변화가 일어나기 직전의 DOM 상태를 가져와서 특정 값을 반환하면, 그 다음 발생하게 되는 componentDidUpdate 함수에서 받아와서 사용할 수 있음.</li>\n<li>componentDidUpdate : <code class=\"language-text\">리렌더링을 마치고, 화면에 우리가 원하는 변화가 모드 반영되고 난 뒤 호출되는 메소드</code>. 3번째 파라미터로 getSnapshotBeforeUpdate에서 반환 값 조회 가능.</li>\n</ul>\n<br/>\n<h3 id=\"unmount\" style=\"position:relative;\"><a href=\"#unmount\" aria-label=\"unmount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unmount</h3>\n<ul>\n<li>componentWillUnmount : <code class=\"language-text\">컴포넌트가 화면에서 사라지기 직전에 호출</code></li>\n</ul>\n<br/>\n<h2 id=\"함수-컴포넌트의-life-cycle\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-life-cycle\" aria-label=\"함수 컴포넌트의 life cycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 컴포넌트의 Life Cycle</h2>\n<p><img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&#x26;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbF6rTe%2FbtrEvNPPvFs%2FkfuXlK3dGF4bJUpKXQcjH1%2Fimg.png\" alt=\"함수형 컴포넌트 Life Cycle\"></p>\n<p><strong>함수 컴포넌트의 생명주기는</strong> 컴포넌트가 호출이 되면 컴포넌트 내부에서 <code class=\"language-text\">return</code>을 통해 화면을 렌더링하고, 그 후 useEffect가 실행되는데, <code class=\"language-text\">useEffect()</code>를 통해서 <code class=\"language-text\">상태의 변경∙컴포넌트의 소멸 등</code>의 이벤트를 관리할 수 있다.</p>\n<p>한개의 컴포넌트 내에서 한개 or 여러개를 선언하여 관리할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 렌더링 결과가 실제 돔에 반영될때 마다 호출</span>\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 컴포넌트가 처음 나타날때 한 번 호출</span>\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>dependencies1<span class=\"token punctuation\">,</span> dependencies2<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 조건부 effect 발생, 의존성 중 하나가 변경된다면, 리렌더링이 일어난다.</span></code></pre></div>\n<br/>\n<h2 id=\"life-cycle에-대한-클래스함수-컴포넌트-비교\" style=\"position:relative;\"><a href=\"#life-cycle%EC%97%90-%EB%8C%80%ED%95%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%95%A8%EC%88%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B9%84%EA%B5%90\" aria-label=\"life cycle에 대한 클래스함수 컴포넌트 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life Cycle에 대한 클래스∙함수 컴포넌트 비교</h2>\n<table>\n<thead>\n<tr>\n<th><strong>분류</strong></th>\n<th><strong>클래스형 컴포넌트</strong></th>\n<th><strong>함수형 컴포넌트</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Mounting</td>\n<td>constructor()</td>\n<td>함수형 컴포넌트 내부</td>\n</tr>\n<tr>\n<td>Mounting</td>\n<td>render()</td>\n<td>return()</td>\n</tr>\n<tr>\n<td>Mounting</td>\n<td>componentDidMount()</td>\n<td>useEffect()</td>\n</tr>\n<tr>\n<td>Updating</td>\n<td>componentDidUpdate()</td>\n<td>useEffect()</td>\n</tr>\n<tr>\n<td>UnMounting</td>\n<td>componentWillUnmount()</td>\n<td>useEffect()</td>\n</tr>\n</tbody>\n</table>\n<br/>\n<h4 id=\"hooks-종류에-대해서\" style=\"position:relative;\"><a href=\"#hooks-%EC%A2%85%EB%A5%98%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C\" aria-label=\"hooks 종류에 대해서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://rnfltpgus.github.io/react/hooks-use/\">Hooks 종류에 대해서</a></h4>\n<br/>\n<h1 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h1>\n<p><a href=\"https://ko.reactjs.org/docs/react-component.html\">React.Component - React</a></p>\n<p><a href=\"https://beta.reactjs.org/apis/react\">react: Hooks</a></p>\n<p><a href=\"https://overreacted.io/a-complete-guide-to-useeffect/\">A Complete Guide to useEffect</a></p>\n<p><a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">React Lifecycle Methods diagram</a></p>\n<p><a href=\"https://adjh54.tistory.com/43\">함수형 컴포넌트 생명주기(lifecycle) 이해하기</a></p>\n<p><a href=\"https://velog.io/@minbr0ther/React.js-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4life-cycle-%EC%88%9C%EC%84%9C-%EC%97%AD%ED%95%A0\">[React.js] 리액트 라이프사이클(life cycle) 순서, 역할, Hook</a></p>\n<p><a href=\"https://velog.io/@youngminss/React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EB%A9%94%EC%84%9C%EB%93%9C\">[React] 컴포넌트 생명주기 메서드</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-life-cycle\">클래스 컴포넌트의 Life Cycle</a></p>\n<ul>\n<li><a href=\"#mount\">Mount</a></li>\n<li><a href=\"#update\">Update</a></li>\n<li><a href=\"#unmount\">Unmount</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%95%A8%EC%88%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-life-cycle\">함수 컴포넌트의 Life Cycle</a></p>\n</li>\n<li>\n<p><a href=\"#life-cycle%EC%97%90-%EB%8C%80%ED%95%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%95%A8%EC%88%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B9%84%EA%B5%90\">Life Cycle에 대한 클래스∙함수 컴포넌트 비교</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"#hooks-%EC%A2%85%EB%A5%98%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C\">Hooks 종류에 대해서</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"🤯 보완예정 Life Cycle이란? 은 페이지에 렌더링 되기 전인 준비과정에서 시작하여, 브라우저에 렌더링 및 업데이트 후 페이지에서 사라질 때 끝난다. 컴포넌트는 를 같는다. 클래스 컴포넌트는 라이플 사이클 메서드를 사용하고, 함수형 컴포넌트는 Hook을 사용한다. (라이프사이클 메소드는 클래스 컴포넌트에서만 사용. 함수형 컴포넌트 → Hooks 사용) 컴포넌트가 처음 렌더링 될 때, 어떤 작업을 처리해야하거나 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 수 도 있고, 불필요한 업데이트를 방지해야 할 수도 있다. 이러한 경우에 컴포넌트 라이프사이클 메소드를 사용한다. Life Cycle의 구성 라이프 사이클은 총 3가지 카테고리로 구성 - Mount, Update, Unmount  접두사 메소드 → 어떤 작업을 작동하기 전에 실행  접두사 메소드 → 어떤 작업을 작동한 후에 실행 클래스 컴포넌트의 Life Cycle 클래스 컴포넌트  Life Cycle Mount c…","frontmatter":{"date":"December 23, 2022","title":"컴포넌트의 생명주기(Life Cycle)","categories":"React","author":"JungSany","emoji":"🏥"},"fields":{"slug":"/react/life-cycle/"}},"next":{"id":"abaf6c36-08f0-5bba-b7a9-2deeb2caeaa4","html":"<p>함수와 함수가 선언된 어휘적 환경의 조합이다.</p>\n<br/>\n<h2 id=\"어휘적-범위-지정lexical-scoping\" style=\"position:relative;\"><a href=\"#%EC%96%B4%ED%9C%98%EC%A0%81-%EB%B2%94%EC%9C%84-%EC%A7%80%EC%A0%95lexical-scoping\" aria-label=\"어휘적 범위 지정lexical scoping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어휘적 범위 지정(Lexical scoping)</h2>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Sanny'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// name은 init에 의해 생성된 지역 변수이다.</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">displayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// displayName() 은 내부 함수이며, 클로저다.</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 부모 함수에서 선언된 변수를 사용한다.</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">displayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>위 코드를 실행하면 <code class=\"language-text\">displayName()</code> 함수 내의 <code class=\"language-text\">alert()</code>문이 부모 함수에서 정의한 변수 <code class=\"language-text\">name</code>의 값을 성공적으로 출력한다.</li>\n<li>이 예시를 통해 함수가 <code class=\"language-text\">중첩된 상황</code>에서 파서가 어떻게 변수를 처리하는지 알 수 있다.</li>\n<li>이는 어휘적 범위 지정(Lexical Scoping)의 한 예이다. 여기서 <code class=\"language-text\">Lexical</code>이란, 어휘적 범위 지정(Lexical Scoping) 과정에서 변수가 어디에서 사용 가능한지 알기 위해 그 변수가 소스코드 내 어디에서 선언되었는지 고려한다는 것을 의미한다.</li>\n<li>단어 <code class=\"language-text\">Lexical</code>은 이런 사실을 나타낸다. <code class=\"language-text\">중첩된 함수</code>는 외부 범위(scope)에서 선언한 변수에도 접근할 수 있다.</li>\n</ul>\n<br/>\n<h2 id=\"클로저closure\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\" aria-label=\"클로저closure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저(Closure)</h2>\n<ul>\n<li>자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성한다.</li>\n<li>클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다.</li>\n<li><code class=\"language-text\">클로저(Closure)</code>는 <strong>내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것</strong>을 말한다.</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%96%B4%ED%9C%98%EC%A0%81-%EB%B2%94%EC%9C%84-%EC%A7%80%EC%A0%95lexical-scoping\">어휘적 범위 지정(Lexical scoping)</a></li>\n<li><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\">클로저(Closure)</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 23, 2022","title":"클로저(Closure)란?","categories":"JavaScript","author":"JungSany","emoji":"📎"},"fields":{"slug":"/javascript/closure/"}},"prev":{"id":"50193ed4-3f05-55a4-804d-fe722515f0d7","html":"<h2 id=\"hooks가-등장한-이유\" style=\"position:relative;\"><a href=\"#hooks%EA%B0%80-%EB%93%B1%EC%9E%A5%ED%95%9C-%EC%9D%B4%EC%9C%A0\" aria-label=\"hooks가 등장한 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hooks가 등장한 이유</h2>\n<ul>\n<li>\n<p>기존의 클래스 문법에서 사용하였던 라이프사이클 메서드 기반은 <code class=\"language-text\">관련 없는 로직이 섞여 코드가 작성되는 경우가 있었고 그로 인해서 버그가 쉽게 발생하고, 무결성을 해치는 경우가 많았다.</code> 때문에 <code class=\"language-text\">로직 기반으로</code> 나눌 수 있고 컴포넌트를 함수 단위로 잘게 쪼갤 수 있는 <code class=\"language-text\">React Hooks</code>가 나와 함수 컴포넌트로 작성하게 되었다.</p>\n</li>\n<li>\n<p><strong>Hooks을 이용하기 위해서는</strong></p>\n<ul>\n<li><code class=\"language-text\">최상위</code>에서만 호출해야하며, <code class=\"language-text\">반복문・조건문・중첩된 함수</code> 내에서 Hook을 실행하면 안 된다.</li>\n</ul>\n</li>\n<li>\n<p>이 규칙을 따르면 컴포넌트가 렌더링될 때마다 동일한 순서로 호출되는 것을 보장할 수 있다.</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"hooks의-종류\" style=\"position:relative;\"><a href=\"#hooks%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"hooks의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hooks의 종류</h2>\n<h3 id=\"usestate\" style=\"position:relative;\"><a href=\"#usestate\" aria-label=\"usestate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useState</h3>\n<ul>\n<li>상태를 변수로 선언하여 관리하며, 상태의 불변성을 유지한 채 상태를 변경할 수 있도록 도와준다.</li>\n<li>[state, setState]의 인자로는\n<ul>\n<li>state: 상태의 <code class=\"language-text\">현재 값이 표현</code>되고 초기에는 사용자가 제공한 초기 상태로 설정되어 표현</li>\n<li>setState: 상호 작용에 따라 다른 값으로 변경</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3 id=\"useeffect\" style=\"position:relative;\"><a href=\"#useeffect\" aria-label=\"useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect</h3>\n<ul>\n<li>컴포넌트 내에 <code class=\"language-text\">변화가 발생했을 경우</code>에 실행되는 메서드</li>\n<li>화면에 렌더링이 완료된 후에 수행된다.</li>\n<li>useEffect(function, …dependencies?);\n<ul>\n<li>function : useEffect가 수행될 때 실행되는 함수</li>\n<li>deps [optional] : 배열 형태이며, 의존(dependency) 값을 의미</li>\n</ul>\n</li>\n<li>useEffect안에서의 return은 <code class=\"language-text\">정리 함수(clean-up)</code>를 사용하기위해 쓰여집니다.\n<ul>\n<li>메모리 누수 방지를 위해 UI에서 컴포넌트를 제거하기 전에 수행한다.</li>\n<li>컴포넌트가 여러 번 렌더링 된다면 다음 effect가 수행되기 전에 이전 effect가 정리된다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 렌더링 결과가 실제 돔에 반영될때 마다 호출</span>\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 컴포넌트가 처음 나타날때 한 번 호출</span>\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>dependencies1<span class=\"token punctuation\">,</span> dependencies2<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 조건부 effect 발생, 의존성 중 하나가 변경된다면, 리렌더링이 일어난다.</span></code></pre></div>\n<br/>\n<h3 id=\"useref\" style=\"position:relative;\"><a href=\"#useref\" aria-label=\"useref permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useRef</h3>\n<ul>\n<li>useState는 상태의 값이 변하면 렌더링이 일어나지만, useRef는 상태의 값이 변하더라도 렌더링을 일으키지 않는다.</li>\n<li><strong>특정 DOM 요소에 접근할때</strong> 사용하는 편이며, <code class=\"language-text\">.current</code> 프로퍼티로 전달된 인자로 초기화된 변경 가능한 ref 객체를 반환한다.\n(JavaScript의 Document.querySelector와 비슷한 기능)</li>\n<li>반환된 객체는 컴포넌트의 전 생애주기를 통해 유지된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> refContainer <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3 id=\"usememo\" style=\"position:relative;\"><a href=\"#usememo\" aria-label=\"usememo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo</h3>\n<ul>\n<li>메모이제이션된 값을 반환한다.</li>\n<li>이미 연산 된 값을 리렌더링 시 다시 계산하지 않도록 한다.</li>\n<li>의존성이 변경되었을 때에만 메모이제이션된 값만 다시 계산한다.</li>\n<li>의존성 배열이 없는 경우 매 렌더링 때마다 새 값을 계산한다.</li>\n<li><strong>유의사항:</strong> 모든 컴포넌트를 useMemo로 감싸게 되면 이 또한 리소스 낭비이므로, 퍼포먼스 최적화가 필요한 연상량이 많은 곳에 사용하는 것이 좋다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> memoizedValue <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">computeExpensiveValue</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3 id=\"usecallback\" style=\"position:relative;\"><a href=\"#usecallback\" aria-label=\"usecallback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback</h3>\n<ul>\n<li>메모이제이션된 콜백을 반환한다.</li>\n<li>useMemo와 유사하게 이용되며, ‘함수’에 적용해준다.</li>\n<li>의존성이 변경되었을때만 변경된다. 그렇기 때문에 특정 함수를 새로 만들지 않고 재사용가능하게 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> memoizedCallback <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3 id=\"usecontext\" style=\"position:relative;\"><a href=\"#usecontext\" aria-label=\"usecontext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useContext</h3>\n<ul>\n<li>Context API를 통해 만들어진 Context에서 제공하는 Value를 가져올 수 있다.</li>\n<li>컴포넌트에서 가장 가까운 &#x3C;MyContext.Provider>가 갱신되면 이 Hook은 그 MyContext provider에게 전달된 가장 최신의 context value를 사용하여 렌더러를 트리거 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> <span class=\"token function\">useContext</span><span class=\"token punctuation\">(</span>MyContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3 id=\"usereducer\" style=\"position:relative;\"><a href=\"#usereducer\" aria-label=\"usereducer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useReducer</h3>\n<ul>\n<li>useState의 대체 함수로 컴포넌트 상태 업데이트 로직을 컴포넌트에서 분리시킬 수 있다.</li>\n<li>컴포넌트 바깥에 로직을 작성할 수 도 있고, 심지어 다른 파일에 작성한 후 불러와서 사용할 수도 있다.</li>\n<li>reducer란 현재 상태와 액션 객체를 파라미터로 받아와서 새로운 상태를 반환해주는 함수이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useReducer</span><span class=\"token punctuation\">(</span>reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h1 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h1>\n<p><a href=\"https://ko.reactjs.org/docs/react-component.html\">React.Component - React</a></p>\n<p><a href=\"https://beta.reactjs.org/apis/react\">react: Hooks</a></p>\n<p><a href=\"https://www.youtube.com/@starcoding/videos\">별코딩 훅에 대해서</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#hooks%EA%B0%80-%EB%93%B1%EC%9E%A5%ED%95%9C-%EC%9D%B4%EC%9C%A0\">Hooks가 등장한 이유</a></p>\n</li>\n<li>\n<p><a href=\"#hooks%EC%9D%98-%EC%A2%85%EB%A5%98\">Hooks의 종류</a></p>\n<ul>\n<li><a href=\"#usestate\">useState</a></li>\n<li><a href=\"#useeffect\">useEffect</a></li>\n<li><a href=\"#useref\">useRef</a></li>\n<li><a href=\"#usememo\">useMemo</a></li>\n<li><a href=\"#usecallback\">useCallback</a></li>\n<li><a href=\"#usecontext\">useContext</a></li>\n<li><a href=\"#usereducer\">useReducer</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 23, 2022","title":"Hooks의 종류","categories":"React","author":"JungSany","emoji":"🛒"},"fields":{"slug":"/react/hooks-use/"}},"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io/","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/react/life-cycle/","nextSlug":"/javascript/closure/","prevSlug":"/react/hooks-use/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
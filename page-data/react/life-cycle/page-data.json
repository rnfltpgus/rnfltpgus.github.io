{"componentChunkName":"component---src-templates-blog-template-js","path":"/react/life-cycle/","result":{"data":{"cur":{"id":"a6b9568c-df86-5095-bc7e-40b769a32a52","html":"<p><img src=\"https://cdn.filestackcontent.com/ApNH7030SAG1wAycdj3H\" alt=\"리엑트 라이프사이클 도표\"></p>\n<h2 id=\"life-cycle이란\" style=\"position:relative;\"><a href=\"#life-cycle%EC%9D%B4%EB%9E%80\" aria-label=\"life cycle이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life Cycle이란?</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">컴포넌트의 수명</code>은 페이지에 렌더링 되기 전인 <strong>준비과정</strong>에서 시작하여, <strong>브라우저에 렌더링 및 업데이트</strong> 후 페이지에서 <strong>사라질 때</strong> 끝난다.</p>\n</li>\n<li>\n<p>컴포넌트는 <code class=\"language-text\">생성(mountion) → 업데이트(updating) → 제거(unmountion)의 생명주기</code>를 같는다.</p>\n</li>\n<li>\n<p><strong>클래스 컴포넌트</strong>는 라이플 사이클 메서드를 사용하고, <strong>함수형 컴포넌트</strong>는 Hook을 사용한다.</p>\n</li>\n<li>\n<p>컴포넌트가 처음 렌더링 될 때, 어떤 작업을 처리해야하거나 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 수 도 있고, 불필요한 업데이트를 방지해야 할 수도 있다. 이러한 경우에 컴포넌트 <strong>라이프사이클 메소드를 사용</strong>한다.</p>\n<p>(라이프사이클 메소드는 <strong>클래스 컴포넌트에서만 사용</strong>. 함수형 컴포넌트 → Hooks 사용)</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"life-cycle의-구성\" style=\"position:relative;\"><a href=\"#life-cycle%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"life cycle의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life Cycle의 구성</h2>\n<ul>\n<li>\n<p>라이프 사이클은 총 3가지 카테고리로 구성 - <strong>Mount</strong>, <strong>Update</strong>, <strong>Unmount</strong></p>\n</li>\n<li>\n<p><strong>라이프 사이클 메소드는 총 9가지다.</strong></p>\n</li>\n<li>\n<p><code class=\"language-text\">will</code> 접두사 메소드 → 어떤 작업을 <strong>작동하기 전</strong>에 실행</p>\n</li>\n<li>\n<p><code class=\"language-text\">Did</code> 접두사 메소드 → 어떤 작업을 <strong>작동한 후</strong>에 실행</p>\n</li>\n</ul>\n<br/>\n<ol>\n<li><strong>Mount</strong></li>\n</ol>\n<ul>\n<li>constructor : 컴포넌트의 생성자 메소드. <code class=\"language-text\">컴포넌트가 만들어지면 가장 먼저 실행</code>됨.</li>\n<li>getDerivedStateFromProps : <code class=\"language-text\">props로 받아온 것을 state에 넣어주고 싶을 때 사용</code>.</li>\n<li>render : <code class=\"language-text\">컴포넌트를 렌더링하는 메소드</code></li>\n<li>componentDidMount : <code class=\"language-text\">컴포넌트의 첫번째 렌더링이 끝나면 호출되는 메소드</code>. 이 메소드가 호출되는 시점에서 우리가 만든 컴포넌트가 화면에 나타난 상태. (여기서 주로 D3, masonry 처럼 DOM을 사용해야하는 외부 라이브러리 연동을 하거나, 해당 컴포넌트에서 필요로하는 데이터를 요청하기 위해 axios, fetch 등을 이용하여 ajax 요청을 하거나, DOM의 속성을 읽거나 직접 변경하는 작업을 진행)</li>\n</ul>\n<br/>\n<ol start=\"2\">\n<li><strong>Update</strong></li>\n</ol>\n<ul>\n<li>getDerivedStateFromProps : <code class=\"language-text\">컴포넌트의 props나 state가 바뀌었을때도 이 메소드가 호출</code>됨.</li>\n<li>ShouldComponenetUpdate : <code class=\"language-text\">컴포넌트가 리렌더링 할지 말지를 결정</code></li>\n<li>render : mount와 상동</li>\n<li>getSnapshotBeforeUpdate : 컴포넌트에 변화가 일어나기 직전의 DOM 상태를 가져와서 특정 값을 반환하면, 그 다음 발생하게 되는 componentDidUpdate 함수에서 받아와서 사용할 수 있음.</li>\n<li>componentDidUpdate : <code class=\"language-text\">리렌더링을 마치고, 화면에 우리가 원하는 변화가 모드 반영되고 난 뒤 호출되는 메소드</code>. 3번째 파라미터로 getSnapshotBeforeUpdate에서 반환 값 조회 가능.</li>\n</ul>\n<br/>\n<ol start=\"3\">\n<li><strong>Unmount</strong></li>\n</ol>\n<ul>\n<li>componentWillUnmount : <code class=\"language-text\">컴포넌트가 화면에서 사라지기 직전에 호출</code></li>\n</ul>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://ko.reactjs.org/docs/react-component.html\">React.Component - React</a></p>\n<p><a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">React Lifecycle Methods diagram</a></p>\n<p><a href=\"https://velog.io/@minbr0ther/React.js-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4life-cycle-%EC%88%9C%EC%84%9C-%EC%97%AD%ED%95%A0\">[React.js] 리액트 라이프사이클(life cycle) 순서, 역할, Hook</a></p>\n<p><a href=\"https://velog.io/@youngminss/React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EB%A9%94%EC%84%9C%EB%93%9C\">[React] 컴포넌트 생명주기 메서드</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#life-cycle%EC%9D%B4%EB%9E%80\">Life Cycle이란?</a></p>\n</li>\n<li>\n<p><a href=\"#life-cycle%EC%9D%98-%EA%B5%AC%EC%84%B1\">Life Cycle의 구성</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"리엑트 라이프사이클 도표 Life Cycle이란? 은 페이지에 렌더링 되기 전인 준비과정에서 시작하여, 브라우저에 렌더링 및 업데이트 후 페이지에서 사라질 때 끝난다. 컴포넌트는 를 같는다. 클래스 컴포넌트는 라이플 사이클 메서드를 사용하고, 함수형 컴포넌트는 Hook을 사용한다. 컴포넌트가 처음 렌더링 될 때, 어떤 작업을 처리해야하거나 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 수 도 있고, 불필요한 업데이트를 방지해야 할 수도 있다. 이러한 경우에 컴포넌트 라이프사이클 메소드를 사용한다. (라이프사이클 메소드는 클래스 컴포넌트에서만 사용. 함수형 컴포넌트 → Hooks 사용) Life Cycle의 구성 라이프 사이클은 총 3가지 카테고리로 구성 - Mount, Update, Unmount 라이프 사이클 메소드는 총 9가지다.  접두사 메소드 → 어떤 작업을 작동하기 전에 실행  접두사 메소드 → 어떤 작업을 작동한 후에 실행 Mount constructor : 컴…","frontmatter":{"date":"December 23, 2022","title":"컴포넌트의 생명주기(Life Cycle)","categories":"React","author":"JungSany","emoji":"🏥"},"fields":{"slug":"/react/life-cycle/"}},"next":{"id":"abaf6c36-08f0-5bba-b7a9-2deeb2caeaa4","html":"<p>함수와 함수가 선언된 어휘적 환경의 조합이다.</p>\n<br/>\n<h2 id=\"어휘적-범위-지정lexical-scoping\" style=\"position:relative;\"><a href=\"#%EC%96%B4%ED%9C%98%EC%A0%81-%EB%B2%94%EC%9C%84-%EC%A7%80%EC%A0%95lexical-scoping\" aria-label=\"어휘적 범위 지정lexical scoping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어휘적 범위 지정(Lexical scoping)</h2>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Sanny'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// name은 init에 의해 생성된 지역 변수이다.</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">displayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// displayName() 은 내부 함수이며, 클로저다.</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 부모 함수에서 선언된 변수를 사용한다.</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">displayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>위 코드를 실행하면 <code class=\"language-text\">displayName()</code> 함수 내의 <code class=\"language-text\">alert()</code>문이 부모 함수에서 정의한 변수 <code class=\"language-text\">name</code>의 값을 성공적으로 출력한다.</li>\n<li>이 예시를 통해 함수가 <code class=\"language-text\">중첩된 상황</code>에서 파서가 어떻게 변수를 처리하는지 알 수 있다.</li>\n<li>이는 어휘적 범위 지정(Lexical Scoping)의 한 예이다. 여기서 <code class=\"language-text\">Lexical</code>이란, 어휘적 범위 지정(Lexical Scoping) 과정에서 변수가 어디에서 사용 가능한지 알기 위해 그 변수가 소스코드 내 어디에서 선언되었는지 고려한다는 것을 의미한다.</li>\n<li>단어 <code class=\"language-text\">Lexical</code>은 이런 사실을 나타낸다. <code class=\"language-text\">중첩된 함수</code>는 외부 범위(scope)에서 선언한 변수에도 접근할 수 있다.</li>\n</ul>\n<br/>\n<h2 id=\"클로저closure\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\" aria-label=\"클로저closure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저(Closure)</h2>\n<ul>\n<li>자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성한다.</li>\n<li>클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다.</li>\n<li><code class=\"language-text\">클로저(Closure)</code>는 <strong>내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것</strong>을 말한다.</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%96%B4%ED%9C%98%EC%A0%81-%EB%B2%94%EC%9C%84-%EC%A7%80%EC%A0%95lexical-scoping\">어휘적 범위 지정(Lexical scoping)</a></li>\n<li><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\">클로저(Closure)</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 23, 2022","title":"클로저(Closure)란?","categories":"JavaScript","author":"JungSany","emoji":"📎"},"fields":{"slug":"/javascript/closure/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/react/life-cycle/","nextSlug":"/javascript/closure/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/react/rendering-in-react/","result":{"data":{"cur":{"id":"3f532bc4-1b47-58cc-98e0-a0f54f06dce4","html":"<h1 id=\"react에서-렌더링이란\" style=\"position:relative;\"><a href=\"#react%EC%97%90%EC%84%9C-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4%EB%9E%80\" aria-label=\"react에서 렌더링이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React에서 렌더링이란?</h1>\n<p><strong>컴포넌트가 현재 props와 state의 상태에 기초하여 UI를 어떻게 구성할지 컴포넌트에게 요청하는 작업을 의미한다.</strong></p>\n<br/>\n<h2 id=\"아래는-url은-리엑트-렌더링을-이해하는데-도움이-되는-내글\" style=\"position:relative;\"><a href=\"#%EC%95%84%EB%9E%98%EB%8A%94-url%EC%9D%80-%EB%A6%AC%EC%97%91%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94%EB%8D%B0-%EB%8F%84%EC%9B%80%EC%9D%B4-%EB%90%98%EB%8A%94-%EB%82%B4%EA%B8%80\" aria-label=\"아래는 url은 리엑트 렌더링을 이해하는데 도움이 되는 내글 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아래는 URL은 리엑트 렌더링을 이해하는데 도움이 되는 내글</h2>\n<ul>\n<li><a href=\"https://rnfltpgus.github.io/react/react-use-reasons/\">React란? 그리고 사용하는 이유와 단점</a></li>\n<li><a href=\"https://rnfltpgus.github.io/react/props-state/\">Props와 State에 대해서</a></li>\n<li><a href=\"https://rnfltpgus.github.io/react/react-immutability/\">React는 왜 불변성을 유지해야되나?</a></li>\n</ul>\n<br/>\n<h2 id=\"렌더링을-만드는-방법\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"렌더링을 만드는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링을 만드는 방법</h2>\n<p>최초 렌더링이 끝난 이후에, 리액트가 리렌더링을 queueing 하는 방법에는 여러가지가 있다.</p>\n<ul>\n<li><strong>클래스 컴포넌트</strong>\n<ul>\n<li>this.setState()</li>\n<li>this.forceUpdate()</li>\n</ul>\n</li>\n<li><strong>함수형 컴포넌트</strong>\n<ul>\n<li>useState()의 setter</li>\n<li>useReducer()의 dispatches</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"일반적인-렌더링-동작\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%8F%99%EC%9E%91\" aria-label=\"일반적인 렌더링 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일반적인 렌더링 동작</h3>\n<p>리액트의 기본적인 동작은 <strong>부모 컴포넌트가 렌더링되면, 리액트는 모든 자식 컴포넌트를 순차적으로 리렌더링 한다</strong>는 것이다.</p>\n<p>풀어서 말하면 <strong>컴포넌트를 렌더링 하는 작업은, 기본적으로, 하위에 있는 모든 컴포넌트 또한 렌더링 하게 된다.</strong></p>\n<ul>\n<li>일반적인 렌더링의 경우, 리액트는 <code class=\"language-text\">props</code>가 변경되어 있는지 신경쓰지 않는다. 부모 컴포넌트가 렌더링되어 있기 때문에, 자식 컴포넌트도 무조건 리렌더링 된다. <code class=\"language-text\">(Diffing 알고리즘(Fiber 알고리즘), 휴리스틱 알고리즘)</code></li>\n<li>즉, 루트에서 <code class=\"language-text\">setState()</code>를 호출한다는 것은, 기본적으로 컴포넌트 트리에 있는 모든 컴포넌트를 렌더링 한다는 것을 의미한다.</li>\n</ul>\n<br/>\n<h3 id=\"리액트-렌더링-규칙\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B7%9C%EC%B9%99\" aria-label=\"리액트 렌더링 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트 렌더링 규칙</h3>\n<ol>\n<li>렌더링은 <code class=\"language-text\">순수</code>해야하고 <code class=\"language-text\">부수작용</code>이 없어야 한다.</li>\n</ol>\n<ul>\n<li><code class=\"language-text\">console.log()</code>도 부수작업을 야기하지만, 어떠한 로직도 망가 뜨리지 않는다. 하지만 <code class=\"language-text\">prop</code>가 변경되는 것 또는 <code class=\"language-text\">렌더링 중간에 ajax 호출</code> 또한 <strong>명백한 부수효과</strong>이며, 이는 무언가를 로직을 망가 트릴 수 있다.</li>\n<li>렌더링 로직이 할 수 없는 것\n<ul>\n<li>존재하는 변수나 객체를 변경해서는 안된다.</li>\n<li><code class=\"language-text\">Math.random()</code>, <code class=\"language-text\">Date.now()</code>와 같은 랜덤 값을 생성할 수 없다.</li>\n<li>네트워크 요청을 할 수 없다.</li>\n<li><code class=\"language-text\">state</code>를 업데이트</li>\n</ul>\n</li>\n<li>렌더링 로직은 아래의 내용이 가능하다.\n<ul>\n<li>렌더링 도중에 새롭게 만들어진 객체를 변경</li>\n<li>에러 던지기</li>\n<li>아직 만들어지지 않은 데이터를 lazy 초기화 하는 일(캐시 같은)</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h2>\n<p><a href=\"https://yceffort.kr/2022/04/deep-dive-in-react-rendering\">리액트의 렌더링은 어떻게 일어나는가?</a></p>\n<p><a href=\"https://gist.github.com/sebmarkbage/75f0838967cd003cd7f9ab938eb1958f\">The Rules of React</a></p>\n<p><a href=\"https://velog.io/@minbr0ther/React.js-Virtual-DOM-%EA%B0%80%EC%83%81-%EB%8F%94\"></a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%95%84%EB%9E%98%EB%8A%94-url%EC%9D%80-%EB%A6%AC%EC%97%91%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94%EB%8D%B0-%EB%8F%84%EC%9B%80%EC%9D%B4-%EB%90%98%EB%8A%94-%EB%82%B4%EA%B8%80\">아래는 URL은 리엑트 렌더링을 이해하는데 도움이 되는 내글</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95\">렌더링을 만드는 방법</a></p>\n<ul>\n<li><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%8F%99%EC%9E%91\">일반적인 렌더링 동작</a></li>\n<li><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B7%9C%EC%B9%99\">리액트 렌더링 규칙</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></p>\n</li>\n</ul>\n</div>","excerpt":"React에서 렌더링이란? 컴포넌트가 현재 props와 state의 상태에 기초하여 UI를 어떻게 구성할지 컴포넌트에게 요청하는 작업을 의미한다. 아래는 URL은 리엑트 렌더링을 이해하는데 도움이 되는 내글 React란? 그리고 사용하는 이유와 단점 Props와 State에 대해서 React는 왜 불변성을 유지해야되나? 렌더링을 만드는 방법 최초 렌더링이 끝난 이후에, 리액트가 리렌더링을 queueing 하는 방법에는 여러가지가 있다. 클래스 컴포넌트 this.setState() this.forceUpdate() 함수형 컴포넌트 useState()의 setter useReducer()의 dispatches 일반적인 렌더링 동작 리액트의 기본적인 동작은 부모 컴포넌트가 렌더링되면, 리액트는 모든 자식 컴포넌트를 순차적으로 리렌더링 한다는 것이다. 풀어서 말하면 컴포넌트를 렌더링 하는 작업은, 기본적으로, 하위에 있는 모든 컴포넌트 또한 렌더링 하게 된다. 일반적인 렌더링의 경우, 리…","frontmatter":{"date":"January 01, 2023","title":"React 렌더링에 대해서","categories":"React","author":"JungSany","emoji":"🎢"},"fields":{"slug":"/react/rendering-in-react/"}},"next":{"id":"89901cf0-cc64-5842-9ecc-e6aeeac71279","html":"<h1 id=\"suspense란\" style=\"position:relative;\"><a href=\"#suspense%EB%9E%80\" aria-label=\"suspense란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Suspense란?</h1>\n<p>컴포넌트의 랜더링을 어떤 작업이 끝날 때까지 <code class=\"language-text\">잠시 중단시키고 다른 컴포넌트를 먼저 랜더링</code>할 수 있다. (아직 개발적인 경험은 작지만, 페이지를 렌더링할때, 외부로 부터 데이터를 받아올때 <code class=\"language-text\">빈 페이지를 보여주기 보다는 로딩 페이지를</code> 보여주게 처리하여 빈 화면이 출력되지 않게 사용한 경험이 있음)</p>\n<p>쉽게 말해 어떤 컴포넌트를 읽어야 하는데, 데이터가 아직 준비되지 않았다고 리엑트에게 알려주는 새로운 매커니즘이다.</p>\n<p>사용방법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 아래와 같이 작성하면 컴포넌트가 포함된 JSX 코드를 랜더링할 때, UserList를 바로 호출함</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserList</span></span> <span class=\"token punctuation\">/></span></span>\n\n<span class=\"token comment\">// 아래와 같이 작성하면 Suspense로 감싼 컴포넌트의 랜더링을 특정 작업 이후로 미루고, 그 작업이 끝날 때 까지는 fallback 속성으로 넘긴 컴포넌트를 대신 보여줄 수 있음</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Suspense</span></span> <span class=\"token attr-name\">fallback</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Spinner</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserList</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Suspense</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<br/>\n<h1 id=\"reactlazy란\" style=\"position:relative;\"><a href=\"#reactlazy%EB%9E%80\" aria-label=\"reactlazy란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.lazy()란?</h1>\n<p>React.lazy 함수를 사용하면 동적으로 컴포넌트를 import하여 렌더링 할 수 있다.</p>\n<p>이를 사용하면 초기 렌더링 지연시간을 어느정도 줄일 수 있다.</p>\n<p>또 이 방법을 사용한다면 <a href=\"https://rnfltpgus.github.io/react/optimization-plan/\">렌더링 관련 최적화를 진행할 수 있다.</a></p>\n<p>만약 서비스를 구성하는 컴포넌트에서 import를 그냥 하게되면 코드가 실행되는 시점에서 모든 import 요소를 읽기 때문인데 불필요하게 읽지 않아도 되는 import 요소를 읽게 된다.</p>\n<p>하지만 <code class=\"language-text\">다이나믹한 임포트 방식</code>인 **React.lazy()**를 이용한다면 필요한 시점에 import 요소를 읽기 때문에 렌더링 최적화 부분에서도 좋은 효과를 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> SomeComponent <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./SomeComponent'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Router로 분기가 나누어진 컴포넌트를 위 처럼 import하면 해당 path로 이동할때 컴포넌트를 불러오게 되는데 이 과적에서 로딩하는 시간이 생기게 된다.</p>\n<ul>\n<li>이 로딩되는 시간 동안 로딩 화면을 보여지도록 해주는 역할을 하는 것이 <code class=\"language-text\">Suspense</code>이다.</li>\n<li>아래의 예시를 참고하면 좋을 것 같다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> Suspense<span class=\"token punctuation\">,</span> lazy <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Routes<span class=\"token punctuation\">,</span> Route <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-router-dom'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> Spinner <span class=\"token keyword\">from</span> <span class=\"token string\">'./items/Spinner'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 기존 import 방식</span>\n<span class=\"token comment\">//import Login from './pages/Login';</span>\n<span class=\"token comment\">//import Main from './pages/Main';</span>\n<span class=\"token comment\">//import Search from './pages/Search';</span>\n<span class=\"token comment\">//import Setting from './pages/Setting';</span>\n\n<span class=\"token comment\">// React.Lazy()를 이용한 방식</span>\n<span class=\"token keyword\">const</span> Main <span class=\"token operator\">=</span> <span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./pages/Main'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> Login <span class=\"token operator\">=</span> <span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./pages/Login'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> Search <span class=\"token operator\">=</span> <span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./pages/Search'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> Setting <span class=\"token operator\">=</span> <span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./pages/Setting'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Suspense</span></span> <span class=\"token attr-name\">fallback</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Spinner</span></span> <span class=\"token attr-name\">text</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>페이지를 불러오는 중 입니다...🏃🏻🏃🏻‍♀️🏃🏻‍♂️<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Routes</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Route</span></span> <span class=\"token attr-name\">exact</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>Main<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Route</span></span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/login<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>Login<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Route</span></span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/setting<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>Setting<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Route</span></span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/search/query=:word<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>Search<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Routes</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Suspense</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> App<span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h2 id=\"생각\" style=\"position:relative;\"><a href=\"#%EC%83%9D%EA%B0%81\" aria-label=\"생각 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>생각</h2>\n<p>코드를 작성하면서 Suspense와 Lazy를 적절하게 섞어서 미리미리 개발한다면 렌더링 최적화에 대해서도, 사용자가 사용하는 입장에서도 많은 이점이 있어 보인다.</p>\n<br/>\n<h2 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h2>\n<p><a href=\"https://beta.reactjs.org/reference/react/Suspense\">Suspense 공식 베타버전</a></p>\n<p><a href=\"https://17.reactjs.org/docs/concurrent-mode-suspense.html\">Suspense for Data Fetching (Experimental) - React</a></p>\n<p><a href=\"https://www.daleseo.com/react-suspense/\">React Suspense 소개 (feat. React v18)</a></p>\n<p><a href=\"https://velog.io/@bbaa3218/React-Suspense%EB%9E%80\">[React] Suspense란?</a></p>\n<p><a href=\"https://ko.reactjs.org/docs/code-splitting.html\">코드 분할 - React</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%83%9D%EA%B0%81\">생각</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">참고자료</a></li>\n</ul>\n</div>","frontmatter":{"date":"January 01, 2023","title":"React - Suspense, lazy에 대해 잠깐","categories":"React","author":"JungSany","emoji":"🩹"},"fields":{"slug":"/react/suspense-lazy/"}},"prev":{"id":"542a0fc8-f9f6-5440-ae1e-d685726b7a75","html":"<h2 id=\"우선-memoization이란\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0-memoization%EC%9D%B4%EB%9E%80\" aria-label=\"우선 memoization이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선 Memoization이란?</h2>\n<p><strong>기존에 수행한 연산의 결과값을 어딘가에 저장해두고 동일한 입력이 들어오면 재활용하는 프로그래밍 기법 이다.</strong></p>\n<p><code class=\"language-text\">memoization</code>을 절적히 적용하면 <strong>중복 연산을 피할 수 있기 때문에 메모리를 조금 더 쓰더라도 애플리케이션의 성능을 최적화</strong>할 수 있습니다.</p>\n<br/>\n<h2 id=\"그리고-react에서-컴포넌트를-다시-실행하는-경우는-아래와-같다\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A6%AC%EA%B3%A0-react%EC%97%90%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%8B%A4%EC%8B%9C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0%EB%8A%94-%EC%95%84%EB%9E%98%EC%99%80-%EA%B0%99%EB%8B%A4\" aria-label=\"그리고 react에서 컴포넌트를 다시 실행하는 경우는 아래와 같다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>그리고 React에서 컴포넌트를 다시 실행하는 경우는 아래와 같다.</strong></h2>\n<ol>\n<li>부모 컴포넌트가 재실행될 때</li>\n<li>props가 변경될 때</li>\n<li>state가 변경되었을 때</li>\n</ol>\n<br/>\n<h2 id=\"reactmemo란\" style=\"position:relative;\"><a href=\"#reactmemo%EB%9E%80\" aria-label=\"reactmemo란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>React.memo란?</strong></h2>\n<p>React.memo는 <strong>High Order Components(HOC)</strong> 이다.</p>\n<p>일반 컴포넌트는 인자로 받은 props를 UI에 활용하는 반면, HOC는 인자로 받은 컴포넌트를 새로운 별도의 컴포넌트로 만든다.</p>\n<p>HOC는 리액트의 API가 아니라, <strong>리액트가 컴포넌트를 구성하는 데 있어서 일종의 패턴</strong>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Movie</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> title<span class=\"token punctuation\">,</span> description <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Movie title: </span><span class=\"token punctuation\">{</span>title<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Release date: </span><span class=\"token punctuation\">{</span>description<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> MemoizedMovie <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>Movie<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><strong>만약 <code class=\"language-text\">컴포넌트가 같은 props를 받을 때 같은 결과를 렌더링한다면</code> React.memo를 사용하여 <code class=\"language-text\">메모이징(Memoizing)된 내용</code>을 <code class=\"language-text\">재사용</code>하여, 불필요한 렌더링을 방지할 수 있다.</strong></li>\n<li>React.memo는 <code class=\"language-text\">오직 props가 변경됐는지 아닌지만 확인</code>한다. 하지만, 함수형 컴포넌트가 함수 내부에서 useState와 같은 Hook을 사용하고 있는 경우에는 상태가 변경 되면 리렌더링 된다.</li>\n</ul>\n<h3 id=\"사용은-언제-해야-될까\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EC%9D%80-%EC%96%B8%EC%A0%9C-%ED%95%B4%EC%95%BC-%EB%90%A0%EA%B9%8C\" aria-label=\"사용은 언제 해야 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용은 언제 해야 될까?</h3>\n<p>같은 props로 렌더링이 자주 일어나는 컴퍼넌트에 대해서 사용하면 좋다고 한다. 잘 알지 못한 상태로 React.memo()를 적용하려고 한다면 필요없는 props 비교하는 상황이 생겨 오히려 성능을 악화시킬 수 있으니 잘 이해하고 쓰는 편이 좋을 것 같다.</p>\n<br/>\n<h2 id=\"usememo란\" style=\"position:relative;\"><a href=\"#usememo%EB%9E%80\" aria-label=\"usememo란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>useMemo란?</strong></h2>\n<p><strong>useMemo는 메모이즈된 값을 return하는 Hook이다.</strong></p>\n<p><strong>useMemo는 이전 값을 기억해두었다가 조건에 따라 재활용하여 성능을 최적화 하는 용도로 사용된다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Movie</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> memoizedMemo <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>memoizedMemo<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>인자로 함수와 Dependencies를 넘겨 받는다. 의존 인자 중에 하나라도 값이 변경되면 1번째 인자의 함수가 재실행된다. 이를 통해 매 렌더링될 때마다 소요되는 불필요한 함수의 실행을 막을 수 있다.</li>\n<li>인자가 빈 배열이라면 매번 새롭게 함수가 실행되어 return한다.</li>\n</ul>\n<h3 id=\"유의사항\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EC%9D%98%EC%82%AC%ED%95%AD\" aria-label=\"유의사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유의사항</h3>\n<p>모든 컴포넌트를 useMemo로 감싸게 되면 이 또한 리소스 낭비이므로, 퍼포먼스 최적화가 필요한 연상량이 많은 곳에 사용하는 것이 좋다.</p>\n<br/>\n<h2 id=\"usecallback란\" style=\"position:relative;\"><a href=\"#usecallback%EB%9E%80\" aria-label=\"usecallback란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>useCallback란?</strong></h2>\n<p><strong><code class=\"language-text\">useCallback</code>은 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용한다.</strong></p>\n<p><strong><code class=\"language-text\">함수를 메모이제이션하기 위해 사용</code>되는 hook 함수로</strong></p>\n<p><strong>useMemo와의 차이는</strong></p>\n<ul>\n<li><code class=\"language-text\">useMemo</code>는 특정 결과값을 재사용할 때 사용하는 반면, <code class=\"language-text\">useCallback</code>은 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용한다는 점이 차이이다.</li>\n</ul>\n<h3 id=\"사용방법은\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95%EC%9D%80\" aria-label=\"사용방법은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용방법은</h3>\n<p>첫번째 인자로 넘어온 함수를, 두번쨰 인자로 넘어온 배열 내의 값이 변경될때까지 저장해 놓고 재사용할 수 있게 해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> memoizedCallback <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span>함수<span class=\"token punctuation\">,</span> 배열<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>예를 들어, 어떤 React 컴포넌트 함수 안에 함수가 선언이 되어 있다면 그 함수는 해당 컴포넌트가 랜더링될 때 마다 새로운 함수를 생성하게 되는데</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">useCallback()</code>을 사용하면, 해당 컴포넌트가 랜더링되더라도 그 함수가 의존하는 값들이 바뀌지 않는 한 기존 함수를 계속해서 반환한다.</p>\n<p>즉, <code class=\"language-text\">x</code> 또는 <code class=\"language-text\">y</code> 값이 바뀌면 새로운 함수가 생성되어 <code class=\"language-text\">add</code> 변수에 할당되고, <code class=\"language-text\">x</code> 와 <code class=\"language-text\">y</code> 값이 동일하다면 다음 랜더링 때 이 함수를 재사용한다.</p>\n<br/>\n<h2 id=\"잡썰\" style=\"position:relative;\"><a href=\"#%EC%9E%A1%EC%8D%B0\" aria-label=\"잡썰 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>잡썰</h2>\n<ol>\n<li>성능에 관한 최적화를 하는 함수라고 하여도 아무떄나 사용하는 것이 아닌 코드적으로 이용을 하여 <code class=\"language-text\">성능적인 퍼포먼스를 낼 수 있는가를 생각해 보아야 된다</code>는 것을 알게 되었다.</li>\n<li><code class=\"language-text\">useCallback()</code> hook 함수는 자식 컴포넌트의 랜더링의 불필요한 랜더링을 줄이기 위해서 <code class=\"language-text\">React.memo()</code> 함수와 같이 사용하면 좋다는 글을 보았는데 이 부분은 경험을 해보아야 느껴질 것 같다.</li>\n</ol>\n<br/>\n<h2 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Memoization\">wikipedia- Memoization</a></p>\n<p><a href=\"https://ui.toast.com/weekly-pick/ko_20190731\">React.memo() 현명하게 사용하기</a></p>\n<p><a href=\"https://www.daleseo.com/react-hooks-use-memo/\">React Hooks: useMemo 사용법</a></p>\n<p><a href=\"https://www.daleseo.com/react-hooks-use-callback/\">React Hooks: useCallback 사용법</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%9A%B0%EC%84%A0-memoization%EC%9D%B4%EB%9E%80\">우선 Memoization이란?</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%A6%AC%EA%B3%A0-react%EC%97%90%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%8B%A4%EC%8B%9C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0%EB%8A%94-%EC%95%84%EB%9E%98%EC%99%80-%EA%B0%99%EB%8B%A4\"><strong>그리고 React에서 컴포넌트를 다시 실행하는 경우는 아래와 같다.</strong></a></p>\n</li>\n<li>\n<p><a href=\"#reactmemo%EB%9E%80\"><strong>React.memo란?</strong></a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%EC%9D%80-%EC%96%B8%EC%A0%9C-%ED%95%B4%EC%95%BC-%EB%90%A0%EA%B9%8C\">사용은 언제 해야 될까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#usememo%EB%9E%80\"><strong>useMemo란?</strong></a></p>\n<ul>\n<li><a href=\"#%EC%9C%A0%EC%9D%98%EC%82%AC%ED%95%AD\">유의사항</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#usecallback%EB%9E%80\"><strong>useCallback란?</strong></a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95%EC%9D%80\">사용방법은</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%A1%EC%8D%B0\">잡썰</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 02, 2023","title":"Hooks의 React.memo과 useMemo 그리고 useCallback에 대해서","categories":"React","author":"JungSany","emoji":"👊"},"fields":{"slug":"/react/hooks-use/hooks-difference/"}},"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/react/rendering-in-react/","nextSlug":"/react/suspense-lazy/","prevSlug":"/react/hooks-use/hooks-difference/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/react/react-immutability/","result":{"data":{"cur":{"id":"3671c8f8-1687-5f94-84e7-a892b6f706b0","html":"<h2 id=\"리액트의-상태-업데이트는-항상-code-classlanguage-text불변적code으로-수행되어야-한다\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8A%94-%ED%95%AD%EC%83%81-code-classlanguage-text%EB%B6%88%EB%B3%80%EC%A0%81code%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"리액트의 상태 업데이트는 항상 code classlanguage text불변적code으로 수행되어야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트의 상태 업데이트는 항상 <code class=\"language-text\">불변적</code>으로 수행되어야 한다.</h2>\n<ul>\n<li><strong>mutate(돌연변이한)한 값의 대상과 위치에 따라 컴포넌트가 렌더링 되지 않을 수 있다.</strong></li>\n<li><strong>데이터가 실제로 업데이트 된 시기와 이유에 대해 혼란을 겪을 수 있다.</strong></li>\n</ul>\n<br/>\n<h2 id=\"불변성이란\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\" aria-label=\"불변성이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변성이란?</h2>\n<ul>\n<li><strong>Immutability(불변성)는 상태나 값을 변경하지 않는 것이다.</strong></li>\n<li>JavaScript에서 예를 들자면,\n<ul>\n<li>JavaScript의 원시 타입의 값들은 <code class=\"language-text\">불변성</code>을 갖고 있다.\n<ul>\n<li><strong>데이터 타입</strong>\n<ul>\n<li><strong>원시 타입(string, number, bigint, boolean, undefined, ES6 부터 추가된 symbol)</strong>\n<ul>\n<li>변경이 불가능한 값(읽기전용)</li>\n<li>원시 값을 변수에 할당하면 확보된 메모리 공간(주소)에는 실제 값이 저장됨</li>\n<li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다.</li>\n</ul>\n</li>\n<li><strong>참조 타입(Object, Array, Function)</strong>\n<ul>\n<li>변경이 가능한 값</li>\n<li>객체를 변수에 할당하면 확보된 메모리 공간에 참조값이 저장됨</li>\n<li>객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>즉, 원시타입은 재할당을 통해서만 변수에 저장한 값을 변경할 수 있지만, 객체타입은 재할당 없이 객체를 직접 동적으로 추가, 삭제 갱신 등이 가능하다는 것이 큰 차이점이다.</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"추가로-javascript에서-얕은-복사와-깊은-복사\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EB%A1%9C-javascript%EC%97%90%EC%84%9C-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"추가로 javascript에서 얕은 복사와 깊은 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가로 JavaScript에서 얕은 복사와 깊은 복사</h3>\n<ul>\n<li>얕은 복사(Shallow copy)\n<ul>\n<li>객체를 프로퍼티 값으로 갖는 객체의 경우에 한 단계 까지만 복사하는 것을 말한다.</li>\n<li>즉, 첫 객체는 새로운 메모리 주소를 가지지만 내부에 있는 중첩된 객체는 얕은 복사를 한 경우에 같은 메모리 주소를 가진다는 의미가 된다.</li>\n<li><strong>얕은 복사 방법으로는 <code class=\"language-text\">Object.assign()</code>, <code class=\"language-text\">전개연산자(spread)</code></strong></li>\n<li><strong>얕은 복사는 하위 중첩되어 있는 객체까지 복사하지 않으므로 공유에 의한 예기치 못한 결과를 얻을 수 있다.</strong></li>\n</ul>\n</li>\n<li>깊은 복사(Deep copy)\n<ul>\n<li><strong>하위에 중첩되어 있는 객체(배열 등)까지 모두 복사하는 것을 말함</strong></li>\n<li>즉, 원시 값처럼 완전히 새로운 메모리 공간을 차지하는 원시값처럼 복사본을 만든다.</li>\n<li><strong>깊은 복사 방법으로는 <code class=\"language-text\">JSON.stringify()</code>, <code class=\"language-text\">재귀함수</code>, <code class=\"language-text\">lodash의 cloneDeep</code></strong></li>\n</ul>\n</li>\n<li><strong>결론으로 객체의 참조 특성으로 인해 복사하고자 하는 객체에 중첩된 객체타입이 있는지를 확인하고 그에 맞는 복사 방법을 사용해야 한다.</strong></li>\n</ul>\n<br/>\n<h2 id=\"그래서-리액트-상태를-변경할-때-불변성을-지켜주어야-되는-이유\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%A0-%EB%95%8C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%A3%BC%EC%96%B4%EC%95%BC-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"그래서 리액트 상태를 변경할 때 불변성을 지켜주어야 되는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래서 리액트 상태를 변경할 때 불변성을 지켜주어야 되는 이유?</h2>\n<ul>\n<li>리액트에서 <code class=\"language-text\">불변성을 지켜주어야 되는 이유</code>는 리액트가 상태 업데이트를 하는 원리 때문이다.</li>\n<li>리액트는 상태 값을 업데이트 할 때 <code class=\"language-text\">얕은 비교</code>로 <strong>상태 변경 여부</strong>를 체크하며, 수행한다.</li>\n<li>즉, <code class=\"language-text\">리액트는</code> 객체의 속성 <strong>하나하나를 비교</strong>하는게 아니라 <code class=\"language-text\">참조 값만 비교하여 상태 변화를 감지</code>한다.</li>\n<li>이런 이유로 리엑트는 state(배열이나 객체)를 <code class=\"language-text\">업데이트 할 때 setState()를 사용</code>하여 <code class=\"language-text\">배열</code>이나 <code class=\"language-text\">객체를 새로 생성</code>해 새로운 참조 값을 만들어 <code class=\"language-text\">상태를 업데이트</code> 한다.</li>\n<li>그리고 리엑트에서 불변성을 지켜주면 다른 이점으로 <code class=\"language-text\">사이드 이펙트를 방지</code>할 수 있다.</li>\n</ul>\n<br/>\n<h3 id=\"정리하자면\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC%ED%95%98%EC%9E%90%EB%A9%B4\" aria-label=\"정리하자면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리하자면</h3>\n<p><strong>리액트는 불변성을 지켜주면 <code class=\"language-text\">효과적인 상태 업데이트(얕은 비교 수행: 계산 리소스를 줄여줌)</code>와 <code class=\"language-text\">사이드 이펙트를 방지하는 이점(원본 데이터를 건들게 될 경우, 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류가 발생할 수 있으며, 프로그래밍의 복잡도가 올라간다.)</code>을 가질 수 있게 된다.</strong></p>\n<br/>\n<h2 id=\"불변성을-지키며-상태를-업데이트-하는-방법은\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B0-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80\" aria-label=\"불변성을 지키며 상태를 업데이트 하는 방법은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변성을 지키며 상태를 업데이트 하는 방법은?</h2>\n<ul>\n<li>\n<p>spread operator, map, filter, slice, reduce 등등 <code class=\"language-text\">새로운 배열을 반환하는 메소드들을 활용</code>하거나</p>\n<ul>\n<li>splice는 원본데이터를 변경하기 때문에 사용하면 안된다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">setState를 이용</code>할 경우</p>\n<ul>\n<li><strong>원시타입인</strong> 경우에는 값을 바로 넣어서 사용해도 되지만</li>\n<li><strong>참조타입인</strong> 경우에는 새로운 객체나 배열을 생성한 후 값을 넣어주어야 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 원시타입</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>number<span class=\"token punctuation\">,</span> setNumber<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 참조타입</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>person<span class=\"token punctuation\">,</span> setPerson<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">33</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>person<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'seahyun'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<br/>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<ul>\n<li><strong>불변성이란</strong> 메모리 영역의 값을 변경하지 않는 것이다.</li>\n<li>리액트는 불변성을 지켜줌으로써 <code class=\"language-text\">효율적인 상태업데이트</code>를 한다.</li>\n<li>리액트는 불변성을 지켜줌으로써 <code class=\"language-text\">사이드 이펙트를 사전 방지하고 프로그래밍의 구조를 단순하게 유지</code>한다.</li>\n<li><strong>불변성을 가진 원시타입과 달리 <code class=\"language-text\">참조타입의 경우에는 의도적으로 불변성을 지켜주어야</code> 한다.</strong>\n<ul>\n<li><code class=\"language-text\">방법으로는</code> <strong>새로운 주소 값을 가진 객체(배열)를 생성하여 상태를 업데이트 해주어야 한다.</strong> 또는 <strong>spread operator, map, filter, slice, reduce 메소드들을 이용하여 새로운 배열의 값을 반환하여 사용</strong>한다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://ko.reactjs.org/tutorial/tutorial.html\">자습서: React 시작하기 - React</a></p>\n<p><a href=\"https://yceffort.kr/2022/04/deep-dive-in-react-rendering\">리액트의 렌더링은 어떻게 일어나는가?</a></p>\n<p><a href=\"https://velog.io/@nomadhash/Java-Script-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC\">[Java Script] 원시타입과 참조타입 👀</a></p>\n<p><a href=\"https://hsp0418.tistory.com/171\">리액트 불변성이란 무엇이고, 왜 지켜야 할까?</a></p>\n<p><a href=\"https://velog.io/@jma1020/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\">리액트에서 불변성이란</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8A%94-%ED%95%AD%EC%83%81-%EB%B6%88%EB%B3%80%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\">리액트의 상태 업데이트는 항상 <code class=\"language-text\">불변적</code>으로 수행되어야 한다.</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\">불변성이란?</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EA%B0%80%EB%A1%9C-javascript%EC%97%90%EC%84%9C-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\">추가로 JavaScript에서 얕은 복사와 깊은 복사</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%A0-%EB%95%8C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%A3%BC%EC%96%B4%EC%95%BC-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">그래서 리액트 상태를 변경할 때 불변성을 지켜주어야 되는 이유?</a></p>\n<ul>\n<li><a href=\"#%EC%A0%95%EB%A6%AC%ED%95%98%EC%9E%90%EB%A9%B4\">정리하자면</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B0-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80\">불변성을 지키며 상태를 업데이트 하는 방법은?</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"리액트의 상태 업데이트는 항상 으로 수행되어야 한다. mutate(돌연변이한)한 값의 대상과 위치에 따라 컴포넌트가 렌더링 되지 않을 수 있다. 데이터가 실제로 업데이트 된 시기와 이유에 대해 혼란을 겪을 수 있다. 불변성이란? Immutability(불변성)는 상태나 값을 변경하지 않는 것이다. JavaScript에서 예를 들자면, JavaScript의 원시 타입의 값들은 을 갖고 있다. 데이터 타입 원시 타입(string, number, bigint, boolean, undefined, ES6 부터 추가된 symbol) 변경이 불가능한 값(읽기전용) 원시 값을 변수에 할당하면 확보된 메모리 공간(주소)에는 실제 값이 저장됨 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다. 참조 타입(Object, Array, Function) 변경이 가능한 값 객체를 변수에 할당하면 확보된 메모리 공간에 참조값이 저장됨 객체를 가르키는 변수를 다른 변수에 할당하면…","frontmatter":{"date":"December 22, 2022","title":"React는 왜 불변성을 유지해야되나?","categories":"개발지식 React JavaScript","author":"JungSany","emoji":"💥"},"fields":{"slug":"/react/react-immutability/"}},"next":{"id":"270d64fa-c51f-56a5-9183-a008a353776e","html":"<p><img src=\"https://facebook.github.io/flux/img/overview/flux-simple-f8-diagram-with-client-action-1300w.png\" alt=\"Flux Architecture 이미지\"></p>\n<ul>\n<li><code class=\"language-text\">대규모 어플리케이션</code>에서 보다 일관된 데이터 관리를 위해 고안된 아키텍처 방식</li>\n<li>기존에 보편적으로 사용된 MVC 패턴의 사용 시, 데이터 흐름의 복잡도가 올라가는 문제가 발생하였고, <code class=\"language-text\">단방향으로 데이터가 흐를 수 있는 설계</code>를 고안하였고, 이것이 Flux 아키텍처이다.</li>\n<li>Flux 흐름\n<ul>\n<li>Action은 버튼을 누르는 것과 사용자 액션에 대한 이벤트 이름이다.</li>\n<li>Dispatcher는 Action에서 발생한 이벤트 이름에 따라 처리할 값들을 Store에 보낼 수 있다.</li>\n<li>Store는 데이터가 저장되어 있는 저장소로 Disspatcher에서 받은 행동에 따라 데이터를 핸들링한다.</li>\n<li>View에서는 Store에서 핸들링한 데이터를 받는다. 그리고 Action을 통해 이벤트를 발생시키는데, 데이터는 전달하지 않는다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://reactjs.org/blog/2014/05/06/flux.html\">Flux: An Application Architecture for React - React Blog</a></p>\n<p><a href=\"https://facebook.github.io/flux/docs/in-depth-overview/\">In-Depth Overview | Flux</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 22, 2022","title":"Flux Architecture","categories":"개발지식 React","author":"JungSany","emoji":"⚡️"},"fields":{"slug":"/react/flux-architecture/"}},"prev":{"id":"abaf6c36-08f0-5bba-b7a9-2deeb2caeaa4","html":"<p>함수와 함수가 선언된 어휘적 환경의 조합이다.</p>\n<br/>\n<h2 id=\"어휘적-범위-지정lexical-scoping\" style=\"position:relative;\"><a href=\"#%EC%96%B4%ED%9C%98%EC%A0%81-%EB%B2%94%EC%9C%84-%EC%A7%80%EC%A0%95lexical-scoping\" aria-label=\"어휘적 범위 지정lexical scoping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어휘적 범위 지정(Lexical scoping)</h2>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Sanny'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// name은 init에 의해 생성된 지역 변수이다.</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">displayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// displayName() 은 내부 함수이며, 클로저다.</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 부모 함수에서 선언된 변수를 사용한다.</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">displayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>위 코드를 실행하면 <code class=\"language-text\">displayName()</code> 함수 내의 <code class=\"language-text\">alert()</code>문이 부모 함수에서 정의한 변수 <code class=\"language-text\">name</code>의 값을 성공적으로 출력한다.</li>\n<li>이 예시를 통해 함수가 <code class=\"language-text\">중첩된 상황</code>에서 파서가 어떻게 변수를 처리하는지 알 수 있다.</li>\n<li>이는 어휘적 범위 지정(Lexical Scoping)의 한 예이다. 여기서 <code class=\"language-text\">Lexical</code>이란, 어휘적 범위 지정(Lexical Scoping) 과정에서 변수가 어디에서 사용 가능한지 알기 위해 그 변수가 소스코드 내 어디에서 선언되었는지 고려한다는 것을 의미한다.</li>\n<li>단어 <code class=\"language-text\">Lexical</code>은 이런 사실을 나타낸다. <code class=\"language-text\">중첩된 함수</code>는 외부 범위(scope)에서 선언한 변수에도 접근할 수 있다.</li>\n</ul>\n<br/>\n<h2 id=\"클로저closure\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\" aria-label=\"클로저closure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저(Closure)</h2>\n<ul>\n<li>자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성한다.</li>\n<li>클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다.</li>\n<li><code class=\"language-text\">클로저(Closure)</code>는 <strong>내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것</strong>을 말한다.</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%96%B4%ED%9C%98%EC%A0%81-%EB%B2%94%EC%9C%84-%EC%A7%80%EC%A0%95lexical-scoping\">어휘적 범위 지정(Lexical scoping)</a></li>\n<li><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\">클로저(Closure)</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 23, 2022","title":"클로저(Closure)란?","categories":"JavaScript","author":"JungSany","emoji":"📎"},"fields":{"slug":"/javascript/closure/"}},"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/react/react-immutability/","nextSlug":"/react/flux-architecture/","prevSlug":"/javascript/closure/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
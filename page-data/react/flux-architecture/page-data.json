{"componentChunkName":"component---src-templates-blog-template-js","path":"/react/flux-architecture/","result":{"data":{"cur":{"id":"dce08db5-6e81-5ce7-ad33-73e5e332a689","html":"<p><img src=\"https://facebook.github.io/flux/img/overview/flux-simple-f8-diagram-with-client-action-1300w.png\" alt=\"Flux Architecture 이미지\"></p>\n<ul>\n<li><code class=\"language-text\">대규모 어플리케이션</code>에서 보다 일관된 데이터 관리를 위해 고안된 아키텍처 방식</li>\n<li>기존에 보편적으로 사용된 MVC 패턴의 사용 시, 데이터 흐름의 복잡도가 올라가는 문제가 발생하였고, <code class=\"language-text\">단방향으로 데이터가 흐를 수 있는 설계</code>를 고안하였고, 이것이 Flux 아키텍처이다.</li>\n<li>Flux 흐름\n<ul>\n<li>Action은 버튼을 누르는 것과 사용자 액션에 대한 이벤트 이름이다.</li>\n<li>Dispatcher는 Action에서 발생한 이벤트 이름에 따라 처리할 값들을 Store에 보낼 수 있다.</li>\n<li>Store는 데이터가 저장되어 있는 저장소로 Disspatcher에서 받은 행동에 따라 데이터를 핸들링한다.</li>\n<li>View에서는 Store에서 핸들링한 데이터를 받는다. 그리고 Action을 통해 이벤트를 발생시키는데, 데이터는 전달하지 않는다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://reactjs.org/blog/2014/05/06/flux.html\">Flux: An Application Architecture for React - React Blog</a></p>\n<p><a href=\"https://facebook.github.io/flux/docs/in-depth-overview/\">In-Depth Overview | Flux</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</div>","excerpt":"Flux Architecture 이미지 에서 보다 일관된 데이터 관리를 위해 고안된 아키텍처 방식 기존에 보편적으로 사용된 MVC 패턴의 사용 시, 데이터 흐름의 복잡도가 올라가는 문제가 발생하였고, 를 고안하였고, 이것이 Flux 아키텍처이다. Flux 흐름 Action은 버튼을 누르는 것과 사용자 액션에 대한 이벤트 이름이다. Dispatcher는 Action에서 발생한 이벤트 이름에 따라 처리할 값들을 Store에 보낼 수 있다. Store는 데이터가 저장되어 있는 저장소로 Disspatcher에서 받은 행동에 따라 데이터를 핸들링한다. View에서는 Store에서 핸들링한 데이터를 받는다. 그리고 Action을 통해 이벤트를 발생시키는데, 데이터는 전달하지 않는다. 참고링크 Flux: An Application Architecture for React - React Blog In-Depth Overview | Flux 참고링크","frontmatter":{"date":"December 22, 2022","title":"Flux Architecture","categories":"개발지식 React","author":"JungSany","emoji":"⚡️"},"fields":{"slug":"/react/flux-architecture/"}},"next":{"id":"434d0351-7e44-5cfc-9376-7d01a7ba38d8","html":"<h2 id=\"둘다-외부의-파일이나-라이브러리의-코드를-불러온다는-목적을-가지고-있다\" style=\"position:relative;\"><a href=\"#%EB%91%98%EB%8B%A4-%EC%99%B8%EB%B6%80%EC%9D%98-%ED%8C%8C%EC%9D%BC%EC%9D%B4%EB%82%98-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%98-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B6%88%EB%9F%AC%EC%98%A8%EB%8B%A4%EB%8A%94-%EB%AA%A9%EC%A0%81%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EB%8B%A4\" aria-label=\"둘다 외부의 파일이나 라이브러리의 코드를 불러온다는 목적을 가지고 있다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>둘다 외부의 파일이나 라이브러리의 코드를 불러온다는 목적을 가지고 있다.</h2>\n<br/>\n<h3 id=\"require--exports\" style=\"position:relative;\"><a href=\"#require--exports\" aria-label=\"require  exports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>require / exports</h3>\n<ul>\n<li><code class=\"language-text\">NodeJS</code>에서 사용되고 있는 <code class=\"language-text\">CommonJS</code> 키워드이고 Ruby 언어 스타일과 비슷하다고 볼수 있다.</li>\n<li>모듈을 내보낼때는 ES6처럼 명시적으로 선언하는 것이 아니라 특정 변수나 그 변수의 속성으로 <code class=\"language-text\">내보낼 객체를 세팅</code>해 줘야 한다.</li>\n<li>특히, 유사해 보이는 export 변수와 module.exports 변수를 상황에 맞게 잘 사용해야 한다.</li>\n<li>기본적으로 2가지 규칙만 기억하면 된다.\n<ul>\n<li>여러개의 객체를 내보낼 경우 → <code class=\"language-text\">export.변수</code> 의 개별 속성으로 할당</li>\n<li>딱 하나의 객체를 내보낼 경우 → <code class=\"language-text\">module.exports = 객체</code> 자체에 할당</li>\n</ul>\n</li>\n<li>노드 프로젝트에서 import를 사용하기 위해서는 <code class=\"language-text\">JSON 속성에 \"type\": \"module\"</code>\n 을 추가해주면 된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./module.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3 id=\"import--export\" style=\"position:relative;\"><a href=\"#import--export\" aria-label=\"import  export permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>import / export</h3>\n<ul>\n<li><code class=\"language-text\">ES6(ES2015)</code>에서 새롭게 도입된 키워드로서 Java나 Python 언어 방식과 비슷하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> name <span class=\"token keyword\">from</span> <span class=\"token string\">'./module.js'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3 id=\"es6-와-commonjs-의-export내보내기-차이점\" style=\"position:relative;\"><a href=\"#es6-%EC%99%80-commonjs-%EC%9D%98-export%EB%82%B4%EB%B3%B4%EB%82%B4%EA%B8%B0-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"es6 와 commonjs 의 export내보내기 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>ES6 와 CommonJS 의 export(내보내기) 차이점</strong></h3>\n<ul>\n<li>CommonJS와 ES6라는 모듈 시스템에서는 <code class=\"language-text\">exports</code> 객체라는 개념이 존재한다.</li>\n<li><code class=\"language-text\">exports</code>는 모듈로부터 내보내지는 데이터들을 담고 있는 하나의 객체이다.</li>\n<li><code class=\"language-text\">NodeJS</code>프로젝트를 진행할때 <code class=\"language-text\">module.exports =</code>라는 모듈 내보내기 구문을 사용했을 것이다.</li>\n<li><code class=\"language-text\">ES6의 export default</code> 구문이 CommonJS의 module.exports 구문 동작을 대체하기 위한 문법이라고 보면 된다.</li>\n</ul>\n<br/>\n<h3 id=\"require와-import의-주요-차이점\" style=\"position:relative;\"><a href=\"#require%EC%99%80-import%EC%9D%98-%EC%A3%BC%EC%9A%94-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"require와 import의 주요 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>require와 import의 주요 차이점</h3>\n<ul>\n<li><code class=\"language-text\">require()</code>는 CommonJS를 사용하는 node.js문이지만 <code class=\"language-text\">import()</code>는 ES6에서만 사용한다.</li>\n<li><code class=\"language-text\">require()</code>는 파일 (어휘가 아님)에 들어있는 곳에 남아 있으며 <code class=\"language-text\">import()</code>는 항상 맨 위로 이동한다.</li>\n<li><code class=\"language-text\">require()</code>는 프로그램의 어느 지점에서나 호출 할 수 있지만 <code class=\"language-text\">import()</code>는 <code class=\"language-text\">파일의 시작 부분에서만</code> 실행할 수 있다. (그렇지만 import 전용 비동기 문법으로 파일 중간에 모듈 불러오기를 할 수 있다.)</li>\n<li>하나의 프로그램에서 두 키워드를 동시에 사용할 수 없다.</li>\n<li>일반적으로 <code class=\"language-text\">import()</code>는 사용자가 <code class=\"language-text\">필요한 모듈 부분 만 선택</code>하고 로드 할 수 있기 때문에 더 선호된다. 또한 <code class=\"language-text\">require()</code>보다 성능이 우수하며 메모리를 절약한다.</li>\n</ul>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://inpa.tistory.com/entry/NODE-%F0%9F%93%9A-require-%E2%9A%94%EF%B8%8F-import-CommonJs%EC%99%80-ES6-%EC%B0%A8%EC%9D%B4-1\">[NODE] 📚 require vs import 문법 비교 (CommonJS vs ES6)</a></p>\n<p><a href=\"https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-import-export-%EC%A0%95%EB%A6%AC?category=889099#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80(HTML)%EC%97%90%EC%84%9C_%EB%AA%A8%EB%93%88_%EC%82%AC%EC%9A%A9_%ED%95%98%EA%B8%B0\">[JS] 📚 모듈 사용하기 import / export 완벽 💯 정리</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%91%98%EB%8B%A4-%EC%99%B8%EB%B6%80%EC%9D%98-%ED%8C%8C%EC%9D%BC%EC%9D%B4%EB%82%98-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%98-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B6%88%EB%9F%AC%EC%98%A8%EB%8B%A4%EB%8A%94-%EB%AA%A9%EC%A0%81%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EB%8B%A4\">둘다 외부의 파일이나 라이브러리의 코드를 불러온다는 목적을 가지고 있다.</a></p>\n<ul>\n<li><a href=\"#require--exports\">require / exports</a></li>\n<li><a href=\"#import--export\">import / export</a></li>\n<li><a href=\"#es6-%EC%99%80-commonjs-%EC%9D%98-export%EB%82%B4%EB%B3%B4%EB%82%B4%EA%B8%B0-%EC%B0%A8%EC%9D%B4%EC%A0%90\"><strong>ES6 와 CommonJS 의 export(내보내기) 차이점</strong></a></li>\n<li><a href=\"#require%EC%99%80-import%EC%9D%98-%EC%A3%BC%EC%9A%94-%EC%B0%A8%EC%9D%B4%EC%A0%90\">require와 import의 주요 차이점</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 22, 2022","title":"require VS import 문법 비교","categories":"개발지식","author":"JungSany","emoji":"⚖️"},"fields":{"slug":"/knowledge/require-import/"}},"prev":{"id":"02c4ea04-ddef-56e0-90e2-5ff978711e51","html":"<h2 id=\"리액트의-상태-업데이트는-항상-code-classlanguage-text불변적code으로-수행되어야-한다\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8A%94-%ED%95%AD%EC%83%81-code-classlanguage-text%EB%B6%88%EB%B3%80%EC%A0%81code%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"리액트의 상태 업데이트는 항상 code classlanguage text불변적code으로 수행되어야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트의 상태 업데이트는 항상 <code class=\"language-text\">불변적</code>으로 수행되어야 한다.</h2>\n<ul>\n<li><strong>mutate(돌연변이한)한 값의 대상과 위치에 따라 컴포넌트가 렌더링 되지 않을 수 있다.</strong></li>\n<li><strong>데이터가 실제로 업데이트 된 시기와 이유에 대해 혼란을 겪을 수 있다.</strong></li>\n</ul>\n<br/>\n<h2 id=\"불변성이란\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\" aria-label=\"불변성이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변성이란?</h2>\n<ul>\n<li><strong>Immutability(불변성)는 상태나 값을 변경하지 않는 것이다.</strong></li>\n<li>JavaScript에서 예를 들자면,\n<ul>\n<li>JavaScript의 원시 타입의 값들은 <code class=\"language-text\">불변성</code>을 갖고 있다.\n<ul>\n<li><strong>데이터 타입</strong>\n<ul>\n<li><strong>원시 타입(string, number, bigint, boolean, undefined, ES6 부터 추가된 symbol)</strong>\n<ul>\n<li>변경이 불가능한 값(읽기전용)</li>\n<li>원시 값을 변수에 할당하면 확보된 메모리 공간(주소)에는 실제 값이 저장됨</li>\n<li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다.</li>\n</ul>\n</li>\n<li><strong>참조 타입(Object, Array, Function)</strong>\n<ul>\n<li>변경이 가능한 값</li>\n<li>객체를 변수에 할당하면 확보된 메모리 공간에 참조값이 저장됨</li>\n<li>객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>즉, 원시타입은 재할당을 통해서만 변수에 저장한 값을 변경할 수 있지만, 객체타입은 재할당 없이 객체를 직접 동적으로 추가, 삭제 갱신 등이 가능하다는 것이 큰 차이점이다.</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"추가로-javascript에서-얕은-복사와-깊은-복사\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EB%A1%9C-javascript%EC%97%90%EC%84%9C-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"추가로 javascript에서 얕은 복사와 깊은 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가로 JavaScript에서 얕은 복사와 깊은 복사</h3>\n<ul>\n<li>얕은 복사(Shallow copy)\n<ul>\n<li>객체를 프로퍼티 값으로 갖는 객체의 경우에 한 단계 까지만 복사하는 것을 말한다.</li>\n<li>즉, 첫 객체는 새로운 메모리 주소를 가지지만 내부에 있는 중첩된 객체는 얕은 복사를 한 경우에 같은 메모리 주소를 가진다는 의미가 된다.</li>\n<li><strong>얕은 복사 방법으로는 <code class=\"language-text\">Object.assign()</code>, <code class=\"language-text\">전개연산자(spread)</code></strong></li>\n<li><strong>얕은 복사는 하위 중첩되어 있는 객체까지 복사하지 않으므로 공유에 의한 예기치 못한 결과를 얻을 수 있다.</strong></li>\n</ul>\n</li>\n<li>깊은 복사(Deep copy)\n<ul>\n<li><strong>하위에 중첩되어 있는 객체(배열 등)까지 모두 복사하는 것을 말함</strong></li>\n<li>즉, 원시 값처럼 완전히 새로운 메모리 공간을 차지하는 원시값처럼 복사본을 만든다.</li>\n<li><strong>깊은 복사 방법으로는 <code class=\"language-text\">JSON.stringify()</code>, <code class=\"language-text\">재귀함수</code>, <code class=\"language-text\">lodash의 cloneDeep</code></strong></li>\n</ul>\n</li>\n<li><strong>결론으로 객체의 참조 특성으로 인해 복사하고자 하는 객체에 중첩된 객체타입이 있는지를 확인하고 그에 맞는 복사 방법을 사용해야 한다.</strong></li>\n</ul>\n<br/>\n<h2 id=\"그래서-리액트-상태를-변경할-때-불변성을-지켜주어야-되는-이유\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%A0-%EB%95%8C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%A3%BC%EC%96%B4%EC%95%BC-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"그래서 리액트 상태를 변경할 때 불변성을 지켜주어야 되는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래서 리액트 상태를 변경할 때 불변성을 지켜주어야 되는 이유?</h2>\n<ul>\n<li>리액트에서 <code class=\"language-text\">불변성을 지켜주어야 되는 이유</code>는 리액트가 상태 업데이트를 하는 원리 때문이다.</li>\n<li>리액트는 상태 값을 업데이트 할 때 <code class=\"language-text\">얕은 비교</code>로 <strong>상태 변경 여부</strong>를 체크하며, 수행한다.</li>\n<li>즉, <code class=\"language-text\">리액트는</code> 객체의 속성 <strong>하나하나를 비교</strong>하는게 아니라 <code class=\"language-text\">참조 값만 비교하여 상태 변화를 감지</code>한다.</li>\n<li>이런 이유로 리엑트는 state(배열이나 객체)를 <code class=\"language-text\">업데이트 할 때 setState()를 사용</code>하여 <code class=\"language-text\">배열</code>이나 <code class=\"language-text\">객체를 새로 생성</code>해 새로운 참조 값을 만들어 <code class=\"language-text\">상태를 업데이트</code> 한다.</li>\n<li>그리고 리엑트에서 불변성을 지켜주면 다른 이점으로 <code class=\"language-text\">사이드 이펙트를 방지</code>할 수 있다.</li>\n</ul>\n<br/>\n<h3 id=\"정리하자면\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC%ED%95%98%EC%9E%90%EB%A9%B4\" aria-label=\"정리하자면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리하자면</h3>\n<p><strong>리액트는 불변성을 지켜주면 <code class=\"language-text\">효과적인 상태 업데이트(얕은 비교 수행: 계산 리소스를 줄여줌)</code>와 <code class=\"language-text\">사이드 이펙트를 방지하는 이점(원본 데이터를 건들게 될 경우, 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류가 발생할 수 있으며, 프로그래밍의 복잡도가 올라간다.)</code>을 가질 수 있게 된다.</strong></p>\n<br/>\n<h2 id=\"불변성을-지키며-상태를-업데이트-하는-방법은\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B0-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80\" aria-label=\"불변성을 지키며 상태를 업데이트 하는 방법은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변성을 지키며 상태를 업데이트 하는 방법은?</h2>\n<ul>\n<li>\n<p>spread operator, map, filter, slice, reduce 등등 <code class=\"language-text\">새로운 배열을 반환하는 메소드들을 활용</code>하거나</p>\n<ul>\n<li>splice는 원본데이터를 변경하기 때문에 사용하면 안된다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">setState를 이용</code>할 경우</p>\n<ul>\n<li><strong>원시타입인</strong> 경우에는 값을 바로 넣어서 사용해도 되지만</li>\n<li><strong>참조타입인</strong> 경우에는 새로운 객체나 배열을 생성한 후 값을 넣어주어야 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 원시타입</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>number<span class=\"token punctuation\">,</span> setNumber<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 참조타입</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>person<span class=\"token punctuation\">,</span> setPerson<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">33</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>person<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'seahyun'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<br/>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<ul>\n<li><strong>불변성이란</strong> 메모리 영역의 값을 변경하지 않는 것이다.</li>\n<li>리액트는 불변성을 지켜줌으로써 <code class=\"language-text\">효율적인 상태업데이트</code>를 한다.</li>\n<li>리액트는 불변성을 지켜줌으로써 <code class=\"language-text\">사이드 이펙트를 사전 방지하고 프로그래밍의 구조를 단순하게 유지</code>한다.</li>\n<li><strong>불변성을 가진 원시타입과 달리 <code class=\"language-text\">참조타입의 경우에는 의도적으로 불변성을 지켜주어야</code> 한다.</strong>\n<ul>\n<li><code class=\"language-text\">방법으로는</code> <strong>새로운 주소 값을 가진 객체(배열)를 생성하여 상태를 업데이트 해주어야 한다.</strong> 또는 <strong>spread operator, map, filter, slice, reduce 메소드들을 이용하여 새로운 배열의 값을 반환하여 사용</strong>한다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://ko.reactjs.org/tutorial/tutorial.html\">자습서: React 시작하기 - React</a></p>\n<p><a href=\"https://yceffort.kr/2022/04/deep-dive-in-react-rendering\">리액트의 렌더링은 어떻게 일어나는가?</a></p>\n<p><a href=\"https://velog.io/@nomadhash/Java-Script-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC\">[Java Script] 원시타입과 참조타입 👀</a></p>\n<p><a href=\"https://hsp0418.tistory.com/171\">리액트 불변성이란 무엇이고, 왜 지켜야 할까?</a></p>\n<p><a href=\"https://velog.io/@jma1020/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\">리액트에서 불변성이란</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8A%94-%ED%95%AD%EC%83%81-%EB%B6%88%EB%B3%80%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\">리액트의 상태 업데이트는 항상 <code class=\"language-text\">불변적</code>으로 수행되어야 한다.</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\">불변성이란?</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EA%B0%80%EB%A1%9C-javascript%EC%97%90%EC%84%9C-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\">추가로 JavaScript에서 얕은 복사와 깊은 복사</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%A0-%EB%95%8C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%A3%BC%EC%96%B4%EC%95%BC-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">그래서 리액트 상태를 변경할 때 불변성을 지켜주어야 되는 이유?</a></p>\n<ul>\n<li><a href=\"#%EC%A0%95%EB%A6%AC%ED%95%98%EC%9E%90%EB%A9%B4\">정리하자면</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B0-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80\">불변성을 지키며 상태를 업데이트 하는 방법은?</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 22, 2022","title":"React는 왜 불변성을 유지해야되나?","categories":"개발지식 React JavaScript","author":"JungSany","emoji":"💥"},"fields":{"slug":"/react/react-immutability/"}},"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/react/flux-architecture/","nextSlug":"/knowledge/require-import/","prevSlug":"/react/react-immutability/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
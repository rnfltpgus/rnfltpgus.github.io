{"componentChunkName":"component---src-templates-blog-template-js","path":"/data/data-structure/structure/","result":{"data":{"cur":{"id":"d37d835c-9865-5dbb-b490-0aaf92f92424","html":"<p><strong>면접을 준비하면서 최근 면접때는 자료구조에 대해서 잘 나오지 않아 생각을 못하고 있었는데, 어제 면접에서 자료구조에 대해서와 장단점 비교에 대한 질문들이 나오게 되었고 나는 당황했다. 그래서 준비가 미비했던걸 인정하고 한번 정리해 보아야겠다. 블로그로 적으면 그래도 한번은 면접때 쭉 볼수 있으니까 말이다.</strong></p>\n<br/>\n<h2 id=\"시간-복잡도에서-대해서-잠깐-알고-아래글을-읽자\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%97%90%EC%84%9C-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9E%A0%EA%B9%90-%EC%95%8C%EA%B3%A0-%EC%95%84%EB%9E%98%EA%B8%80%EC%9D%84-%EC%9D%BD%EC%9E%90\" aria-label=\"시간 복잡도에서 대해서 잠깐 알고 아래글을 읽자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도에서 대해서 잠깐 알고 아래글을 읽자</h2>\n<p>아래 글을 읽으면서 시간 복잡도라는 것을 작성했는데, <strong><code class=\"language-text\">시간복잡도란 무엇일까?</code></strong></p>\n<p><strong>알고리즘의 로직을 코드로 구현할 때 보통 많이 볼 수 있는데, 시간 복잡도를 고려한다는 말은 ‘입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?’라는 말이다.</strong></p>\n<p>효율적인 알고리즘을 구현한다는 것은 시간복잡도를 고려한다는 말이고 다시 말하면 <code class=\"language-text\">입력값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘을 구성했다</code>는 이야기이다.</p>\n<p>시간 복잡도는 보통 <strong><code class=\"language-text\">Big-O 표기법</code></strong> 으로 나타낸다.</p>\n<p><strong><a href=\"https://www.bigocheatsheet.com/\">Big-O 표기법</a>은 <code class=\"language-text\">입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?</code>를 표기하는 방법이다.</strong></p>\n<br/>\n<h1 id=\"자료구조란\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EB%9E%80\" aria-label=\"자료구조란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자료구조란?</h1>\n<p>우선 자료구조에 대허서 설명해보려고 한다.</p>\n<p><strong><code class=\"language-text\">자료구조란</code> 컴퓨터 과학에서 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미한다.</strong></p>\n<p><strong>더 정확히 말해, 자료 구조는 데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미한다.</strong></p>\n<p>어떤 문제에 대해서 효과적으로 적용된 자료구조는 실행시간 혹은 메모리 용량과 같은 자원을 최소한으로 사용하면서 연산을 수행하도록 해준다.</p>\n<br/>\n<h2 id=\"자료구조의-종류\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"자료구조의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자료구조의 종류</h2>\n<p>자료구조의 종류는 구현에 따라, 형태에 따라 맞는 방법으로 구현하는 것이 좋은데,</p>\n<p>크게는 단순 구조와 자료 간 관계가 <code class=\"language-text\">1:1</code>인 <strong>선형 구조</strong>, <code class=\"language-text\">1:다</code> or <code class=\"language-text\">다:다</code> 구조인 <strong>비선형 구조</strong>, 마지막으로 <strong>파일 구조</strong>로 나누어 진다.</p>\n<p><img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&#x26;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99E4BA415AEB1E9801\" alt=\"자료구조 종류 이미지\"></p>\n<br/>\n<h2 id=\"구현에-따라\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84%EC%97%90-%EB%94%B0%EB%9D%BC\" aria-label=\"구현에 따라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구현에 따라</h2>\n<h3 id=\"배열array\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4array\" aria-label=\"배열array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열(Array)</h3>\n<p><img src=\"https://poiemaweb.com/assets/fs-images/27-2.png\" alt=\"배열 이미지\"></p>\n<ul>\n<li><strong>가장 일반적이고 기본적인 구조이다.</strong></li>\n<li>배열은 <code class=\"language-text\">인덱스(Index)</code>와 인덱스에 해당하는 <code class=\"language-text\">요소(Element)</code>로 구성된다.</li>\n<li><strong>길이가 고정되어 생성된다.</strong>(<code class=\"language-text\">정적 메모리 할당</code>)</li>\n<li>인덱스를 통해서 각 요소에 직접 접근할 수 있다.</li>\n<li>배열은 논리적 순서와 물리적 순서가 일치한다. <a href=\"https://rnfltpgus.github.io/javascript/array-javascriptarray/\">인접한 메모리 위치에 연이어 저장</a>된다.</li>\n</ul>\n<h4 id=\"시간-복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h4>\n<ul>\n<li>\n<p><strong>검색(Search)</strong> : 요소마다 인덱스를 부여했기 때문에, 특정 요소를 접근하는 시간 복잡도는 <code class=\"language-text\">O(1)</code>이다. 하지만, 인덱스를 모르는 특정 값을 찾기 위해서는 배열의 모든 요소들을 살펴봐야 하기 때문에 <code class=\"language-text\">O(n)</code>이다.</p>\n</li>\n<li>\n<p><strong>추가/삭제(Insert/Delete)</strong> : 삽입이나 삭제를 하기 위해서는 길이가 고정되어 있기 때문에 차례대로 한 칸씩 밀어야 하는 과정이 필요하고 그 과정에서 <code class=\"language-text\">O(n)</code>의 시간 복잡도가 생긴다.</p>\n</li>\n</ul>\n<br/>\n<h3 id=\"튜플tuple---code-classlanguage-text자바스크립트에서는-다루지-않음code\" style=\"position:relative;\"><a href=\"#%ED%8A%9C%ED%94%8Ctuple---code-classlanguage-text%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EB%8A%94-%EB%8B%A4%EB%A3%A8%EC%A7%80-%EC%95%8A%EC%9D%8Ccode\" aria-label=\"튜플tuple   code classlanguage text자바스크립트에서는 다루지 않음code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>튜플(Tuple) - <strong><code class=\"language-text\">자바스크립트에서는 다루지 않음</code></strong></h3>\n<ul>\n<li>둘 이상의 자료형을 묶음으로 다루는 구조이다.</li>\n<li>셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 다룬다.</li>\n<li>**<code class=\"language-text\">,</code>**로 구분된 값으로 이루어지는 <strong>불변 시퀀스 타입</strong>이다.</li>\n<li><strong><code class=\"language-text\">수정이랑 삭제</code>가 되지않아 읽을 수만 있게 하고 싶을때 또는 수정하면 안 되는 자료를 쓸때 사용한다.</strong></li>\n</ul>\n<br/>\n<h3 id=\"연결-리스트linkedlist\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8linkedlist\" aria-label=\"연결 리스트linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연결 리스트(LinkedList)</h3>\n<p><img src=\"https://visualgo.net/img/gif/list.gif\" alt=\"연결 리스트 이미지\"></p>\n<ul>\n<li><strong><code class=\"language-text\">배열의 추가/삭제 연산에 대한 비효율성</code>을 <code class=\"language-text\">극복하고자</code> 등장한 데이터 구조이다.</strong>\n<ul>\n<li><code class=\"language-text\">요소를 접근할때 순차적으로 접근해야되는 특성</code>을 가진 배열과 동일하게 링크드 리스트도 순차적 접근을 해야 한다.</li>\n<li>배열과 다르게 인덱스를 가지고 물리적 배치를 사용하지 않고, <code class=\"language-text\">참조 시스템을 사용</code>한다.</li>\n</ul>\n</li>\n<li><strong><code class=\"language-text\">노드를 단위로 구성</code>되어 있으며, 노드는 <code class=\"language-text\">초기값 또는 입력된 값과 다음 노드를 가리키는 참조값으로 구성</code>되어 있고 노드가 다음 요소에 대해 가르키지 않고 있다면 리스트의 끝이라 판단한다.</strong></li>\n<li>새로운 요소가 추가될 때 런타임에 메모리를 할당한다.(동적 메모리 할당)</li>\n<li>연결 리스트는 아래와 같이 목적 방식에 따라 구현할 수 있다.\n<ul>\n<li><strong>원형 연결 리스트</strong> : 각 노드는 다음 노드를 가리키고, 마지막 노드가 처음 노드를 가리키는 연결 리스트이다.</li>\n<li><strong>이중 연결 리스트</strong> : 각 노드는 이전 노드와 다음 노드를 가리키는 참조값으로 구성된다. 처음 노드의 이전 노드와 마지막 노드의 다음 노드는 없다.</li>\n<li><strong>환형 이중 연결 리스트</strong> : 처음 노드가 이전 노드로 마지막 노드를 가리키고, 마지막 노드가 다음 노드로 처음 노드를 가리키는 이중 연결 리스트이다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"시간-복잡도-1\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-1\" aria-label=\"시간 복잡도 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h4>\n<ul>\n<li>\n<p><strong>검색(Search)</strong> : 처음부터 순차적으로 접근해야 하기 때문에 <code class=\"language-text\">O(n)</code>의 시간 복잡도를 갖는다.</p>\n</li>\n<li>\n<p><strong>추가/삭제(Insert/Delete)</strong> : 동적인 메모리 크기를 갖기 때문에, 새로운 요소를 추가하거나 삭제할 경우에 해당되는 부분만 변경하면 되기 때문에 <code class=\"language-text\">O(1)</code>의 시간 복잡도를 갖는다.</p>\n</li>\n</ul>\n<br/>\n<h3 id=\"해시-테이블-hash-tables--hash-map\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-hash-tables--hash-map\" aria-label=\"해시 테이블 hash tables  hash map permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시 테이블 (Hash Tables / Hash Map)</h3>\n<p><img src=\"https://visualgo.net/img/gif/hashtable.gif\" alt=\"Hash Tables 이미지\"></p>\n<ul>\n<li>개체가 해시값에 따라 인덱싱된다.</li>\n<li>대량의 정보를 저장하고 특정 요소를 효율적으로 검색할 수 있는 복잡한 데이터 구조다.</li>\n<li><strong><code class=\"language-text\">해시 테이블을 구현하기 위해서는</code> 연결 리스트(LinkedList)와 해시 함수(Hash FUnction)이 필요하다.</strong></li>\n<li><code class=\"language-text\">특정한 키(key)</code>에 대해서 해시 함수 또는 해시 알고리즘을 통해 <code class=\"language-text\">일정한 길이의 해시(hash)</code>를 만들어내고, <code class=\"language-text\">버킷(bucket)</code>에 저장한다. 이후에 같은 키에 대해서 같은 해시를 만들어내고, <strong>해시를 통해 해당 값(value)을 조회</strong>할 수 있다.</li>\n<li><code class=\"language-text\">해싱(Hashing)</code>은 <strong>해시 함수를 통해서 임의의 값을 고정된 크기의 값으로 변환하는 작업</strong>을 말하는데, 키 값을 입력받아서 해시 함수를 통해 얻은 해시(Hash)를 배열의 인덱스로 환산해서 값에 접근하는 것을 의미한다.</li>\n<li>하지만 <strong>입력된 키의 해시 값이 이미 데이터가 저장된 버킷을 가리키어 <code class=\"language-text\">해시 충돌</code>이 일어날 수 있는데</strong>, 해시 충돌은 <code class=\"language-text\">자료구조나 알고리즘의 효율성을 떨어지기</code> 때문에 <strong>해시 함수는 해시 충돌이 자주 발생하지 않도록 구성</strong>되어야 한다.</li>\n</ul>\n<h4 id=\"충돌-해결-방법\" style=\"position:relative;\"><a href=\"#%EC%B6%A9%EB%8F%8C-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" aria-label=\"충돌 해결 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>충돌 해결 방법</h4>\n<ul>\n<li><strong>분리 연결볍(Separate Chaining)</strong> : Linked List 혹은 Tree를 사용하는 방법이다. 충돌이 발생하는 경우 인덱스가 가리키고 있는 값에 노드를 추가하여 값을 추가한다. 대신, 두 방법 모두 많이 추가하면 비효율적이다.</li>\n<li><strong>개방 주소법(Open Addressing)</strong> : 해시 테이블의 빈공간을 사용하는 방법이다. 추가적인 메모리 공간을 필요하지 않은 장점이 있다. 그 방법에는 Linear Probing, Quadratic Probing, Double Hashing 등이 있다.</li>\n</ul>\n<h4 id=\"시간-복잡도-2\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-2\" aria-label=\"시간 복잡도 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h4>\n<ul>\n<li>키 값을 배열의 인덱스로 사용하기 때문에, 값을 직접 접근할 수 있다. 따라서, 해시 테이블의 평균 시간 복잡도는 <code class=\"language-text\">O(1)</code>이다.(충돌(Collision)이 일어나는 경우 <code class=\"language-text\">O(n)</code>)</li>\n</ul>\n<br/>\n<h2 id=\"형태에-따라\" style=\"position:relative;\"><a href=\"#%ED%98%95%ED%83%9C%EC%97%90-%EB%94%B0%EB%9D%BC\" aria-label=\"형태에 따라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>형태에 따라</h2>\n<h3 id=\"선형-구조\" style=\"position:relative;\"><a href=\"#%EC%84%A0%ED%98%95-%EA%B5%AC%EC%A1%B0\" aria-label=\"선형 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선형 구조</h3>\n<h4 id=\"스택stack\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9Dstack\" aria-label=\"스택stack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택(Stack)</h4>\n<p><img src=\"https://blog.kakaocdn.net/dn/CSWsW/btq2t9Wc0um/qTQgiVXqjxA0l9weuUKTH1/img.png\" alt=\"Stack 이미지\"></p>\n<ul>\n<li><strong>스택 자료구조는 <code class=\"language-text\">후입선출 방식</code>으로 먼저 저장된 것이 꺼내어 슬 때는 제일 나중에 나온다.(LIFO(Last In First Out) 메커니즘)</strong> 반대로, 가장 최근에 저장된 것이 꺼내어 쓸 때는 제일 먼저 나온다. 만약, 자료들의 나열 순서를 바꾸고 싶다면 스택에 집어 넣었다가 꺼내면 역순으로 바뀐다.</li>\n<li>동적 메모리 방식을 취한다.</li>\n</ul>\n<h4 id=\"시간-복잡도-3\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-3\" aria-label=\"시간 복잡도 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h4>\n<ul>\n<li><strong>검색(Search)</strong> : 처음부터 순차적으로 접근해야 하기 때문에 <code class=\"language-text\">O(n)</code>의 시간 복잡도를 갖는다.</li>\n<li><strong>추가/삭제(Insert/Delete)</strong> : 가장 위에 데이터를 추가하거나 삭제하기 때문에 <code class=\"language-text\">O(1)</code>의 시간 복잡도를 갖는다.</li>\n</ul>\n<br/>\n<h4 id=\"큐queue\" style=\"position:relative;\"><a href=\"#%ED%81%90queue\" aria-label=\"큐queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>큐(Queue)</h4>\n<p><img src=\"https://cdn.programiz.com/sites/tutorial2program/files/queue.png\" alt=\"Queue 이미지\"></p>\n<ul>\n<li><strong>스택과 반대로 큐 자료구조는 <code class=\"language-text\">선입선출 방식</code>으로 먼저 저장된 것이 제일 먼저 나온다.(FIFO(First In First Out) 메커니즘) 반대로, 가장 나중에 저장된 것이 꺼내어 쓸 때는 가장 나중에 나온다.</strong></li>\n<li>동적 메모리 방식을 취한다.</li>\n<li>환형 큐 : 한정된 길이 안에서 부수적인 작업 없이 읽고 쓰기를 할 수 있는 큐이다.</li>\n</ul>\n<h4 id=\"시간-복잡도-4\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-4\" aria-label=\"시간 복잡도 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h4>\n<ul>\n<li><strong>검색(Search)</strong> : 처음부터 순차적으로 접근해야 하기 때문에 <code class=\"language-text\">O(n)</code>의 시간 복잡도를 갖는다.</li>\n<li><strong>추가/삭제(Insert/Delete)</strong> : 추가는 front에서만 일어나고 삭제는 항상 rear에서만 일어나므로 <code class=\"language-text\">O(1)</code>의 시간 복잡도를 갖는다.</li>\n</ul>\n<br/>\n<h4 id=\"덱deque\" style=\"position:relative;\"><a href=\"#%EB%8D%B1deque\" aria-label=\"덱deque permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>덱(Deque)</h4>\n<p><img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&#x26;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FptOhu%2FbtqRTSqAZRB%2FOrlMCriLQ3RTFVNB7hhRLk%2Fimg.png\" alt=\"Deque 이미지\"></p>\n<ul>\n<li>Double-ended queue의 약자로 삽입과 삭제가 양쪽 끝에서 모두 발생할 수 있는 선형 자료구조이다.</li>\n<li>덱이라고도 불리지만 <code class=\"language-text\">양방향 큐</code>라고도 불리는 듯하다.</li>\n</ul>\n<br/>\n<h3 id=\"비선형-구조\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%84%A0%ED%98%95-%EA%B5%AC%EC%A1%B0\" aria-label=\"비선형 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비선형 구조</h3>\n<h4 id=\"그래프graph\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84graph\" aria-label=\"그래프graph permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래프(Graph)</h4>\n<p><img src=\"https://blog.kakaocdn.net/dn/dLxFmq/btqzt3V6A8w/mIsOTwkyY4dZZI8btUS7q0/img.jpg\" alt=\"Graph 이미지\"></p>\n<ul>\n<li>\n<p><strong><code class=\"language-text\">객체 간의 연결(Edge)</code>을 시각화한 것으로 <code class=\"language-text\">정점(Vertex)간의 관계</code>를 표현하는 자료구조</strong>로 꼭짓점과 꼭짓점을 잇는 단순한 형태의 자료구이다.</p>\n</li>\n<li>\n<p><strong>그래프는 변이 방향성을 가지는 가, 안가지는 가에 따라서 그래프를 분류할 수 있는데, 방향성이 있다면(Directed) 없다면(Undirected)</strong></p>\n</li>\n<li>\n<p>새로운 요소들의 추가/삭제가 용이하고 효율적이다.</p>\n</li>\n<li>\n<p>그래프 역시 입력된 키의 해시값이 이미 데이터가 저장된 버킷을 가르킬 수 있기 때문에 <code class=\"language-text\">충돌이 일어날 수 있다.</code></p>\n<p><img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&#x26;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fnl3ll%2Fbtq45OhCWXh%2FOQsbfvkUBp9tKX0H2syWGK%2Fimg.png\" alt=\"Directed와 Undirected 그래프 이미지\"></p>\n</li>\n<li>\n<p><strong>유향 그래프(Directed)</strong> : 변의 방향은 보통 부모를 가리키도록 구현된다.</p>\n</li>\n<li>\n<p><strong>무향 그래프(Undirected)</strong> : 순환이 없는 연결 그래프로 구현된다.</p>\n</li>\n</ul>\n<h4 id=\"시간-복잡도-5\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-5\" aria-label=\"시간 복잡도 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h4>\n<p><strong>그래프(Graph)의 시간 복잡도∙공간 복잡도는 노드(N), 정점(V), 엣지(E)를 사용하여 표현한다.</strong></p>\n<ul>\n<li><strong>두 노드의 연결 확인</strong> : 인접 행렬의 경우 고유 인덱스로 바로 접근 가능하여 <code class=\"language-text\">O(1)</code>의 시간 복잡도를 갖는다. 인접 리스트의 경우 한 노드의 인접 리스트 안의 특정 노드가 있는지 확인해야 하기 때문에, 최악의 경우 전체를 봐야하므로 <code class=\"language-text\">O(N)</code> or <code class=\"language-text\">O(V)</code>의 시간 복잡도를 갖는다.</li>\n<li><strong>한 노드에 연결된 모든 노드 확인</strong> : 인접 행렬의 경우 특정 노드를 나타내는 행렬을 돌아서 연결된 노드를 가져와야 하기 때문에, <code class=\"language-text\">O(N)</code> or <code class=\"language-text\">O(V)</code>의 시간 복잡도를 갖는다. 인접 리스트의 경우 연결된 노드의 갯수는 곧 엣지의 갯수이므로, 엣지의 갯수만 확인하면 되므로 <code class=\"language-text\">O(E)</code>의 시간 복잡도를 갖는다.</li>\n<li><strong>추가/삭제(Insert/Delete)</strong> : 추가의 경우 노드/정점이나 엣지 모두 <code class=\"language-text\">O(1)</code>의 시간 복잡도를 갖는다. 하지만, 삭제의 경우에는 노드/정점의 경우 특정 노드/정점을 찾는 시간과 그와 연결된 엣지를 삭제해야 하므로 <code class=\"language-text\">O(N+E)</code> or <code class=\"language-text\">O(V+E)</code>의 시간 복잡도를 갖는다. 엣지의 경우 특정 엣지를 찾는 시간이 소요되므로 <code class=\"language-text\">O(E)</code>의 시간 복잡도를 갖는다.</li>\n</ul>\n<br/>\n<h4 id=\"트리tree\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%A6%ACtree\" aria-label=\"트리tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트리(Tree)</h4>\n<p><img src=\"https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/07/%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5-%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8B%E1%85%A5.png?resize=975%2C551&#x26;ssl=1\" alt=\"Tree 이미지\"></p>\n<ul>\n<li><strong>노드로 구성된 계층적 자료구조이다.</strong></li>\n<li>뿌리와, 뿌리 또는 다른 꼭짓점을 단 하나의 부모로 갖는 꼭짓점들로 이루어진 구조이며, 부모 자식 관계는 변으로 표현된다.</li>\n<li><code class=\"language-text\">최상위(Root)노드</code>를 만들고, <code class=\"language-text\">부모(Parent)노드</code>에 <code class=\"language-text\">자식(Child)노드</code>를 추가하고 그리고 그 자식 노드가 부모 노드로써 또 다른 자식 노드를 추가하는 구조를 가지고 있다.</li>\n<li>트리에 또 다른 트리가 있는 <code class=\"language-text\">재귀적 자료구조</code>이다.</li>\n<li>트리는 아래와 같이 목적 방식에 따라 구현할 수 있다.\n<ul>\n<li><strong>이진 트리(Binary Tree)</strong> : 모든 노드들이 둘 이하의 자식을 가진 트리</li>\n<li><strong>이진탐색 트리(Binary Search Tree)</strong> : 이진탐색(binary search)과 연결리스트(linked list)를 결합한 방식</li>\n<li><strong>균형 트리(Balanced Tree)</strong> : 이진 탐색트리에 새로운 노드가 삽입이 되면 부모의 노드보다 작은 값은 왼쪽으로 큰 값은 오른쪽으로 추가하면서 서브트리가 계속 구성되는 방식</li>\n<li><strong>힙 트리(Heap Tree)</strong> : 부모의 값은 항상 자식(들)의 값보다 크거나(Max heap), 작아야(Min heap)하는 규칙을 가진 트리로 여러개의 값 중에서 가장 크거나 작은 값을 빠르게 찾기 위해 만들어짐</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"시간-복잡도-6\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-6\" aria-label=\"시간 복잡도 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h4>\n<p><strong>일반적인 Tree의 시간복잡도는 아래와 같다.</strong></p>\n<ul>\n<li><strong>검색(Search)</strong> : 특정 값을 탐색하거나, 조회 할 때 <code class=\"language-text\">O(n)</code>의 시간복잡도</li>\n<li><strong>추가(Insert)</strong> : 특정 노드의 child node를 생성해주려면 특정 노드를 찾고 <code class=\"language-text\">O(n)</code>, 그 노드의 childNode에 추가하면 <code class=\"language-text\">O(1)</code>의 시간복잡도를 가진다.</li>\n<li><strong>삭제(Delete)</strong> : 삭제하고자 하는 노드의 부모 노드를 찾은 뒤에 <code class=\"language-text\">O(n)</code> 삭제하고자 하는 노드를 부모 노드의 childNode 리스트에서 지워주면 <code class=\"language-text\">O(1)</code>의 시간복잡도를 가진다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p><strong>한번으로는 이해가 되지 않을 테니 종종 읽고 상세 자료구조에 대해서는 글을 분리하여 작성해야겠다.</strong></p>\n<br/>\n<h2 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h2>\n<p><a href=\"https://visualgo.net/en\">VISUALGO.net</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0\">위키백과 - 자료 구조</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%EC%B6%A9%EB%8F%8C\">해시 충돌</a></p>\n<p><a href=\"https://adrianmejia.com/\">adrianmejia</a></p>\n<p><a href=\"https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/\">[알고리즘] Time Complexity (시간 복잡도)</a></p>\n<p><a href=\"https://velog.io/@jha0402/Data-structure-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-7%EA%B0%80%EC%A7%80-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\">[Data structure] 개발자라면 꼭 알아야 할 7가지 자료구조</a></p>\n<p><a href=\"https://re-code-cord.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC\">[자료구조] 대표적인 자료구조 정리</a></p>\n<p><a href=\"https://blog.naver.com/PostView.nhn?blogId=soj12345&#x26;logNo=221373403400&#x26;parentCategoryNo=&#x26;categoryNo=14&#x26;viewDate=&#x26;isShowPopularPosts=false&#x26;from=postView\">[Python] 자료형4- 튜플형</a></p>\n<p><a href=\"https://suyeon96.tistory.com/24\">[자료구조] 덱 (Deque)</a></p>\n<p><a href=\"https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/\">[알고리즘] Time Complexity (시간 복잡도)</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%97%90%EC%84%9C-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9E%A0%EA%B9%90-%EC%95%8C%EA%B3%A0-%EC%95%84%EB%9E%98%EA%B8%80%EC%9D%84-%EC%9D%BD%EC%9E%90\">시간 복잡도에서 대해서 잠깐 알고 아래글을 읽자</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%A2%85%EB%A5%98\">자료구조의 종류</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B5%AC%ED%98%84%EC%97%90-%EB%94%B0%EB%9D%BC\">구현에 따라</a></p>\n<ul>\n<li>\n<p><a href=\"#%EB%B0%B0%EC%97%B4array\">배열(Array)</a></p>\n<ul>\n<li><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\">시간 복잡도</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%8A%9C%ED%94%8Ctuple---%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EB%8A%94-%EB%8B%A4%EB%A3%A8%EC%A7%80-%EC%95%8A%EC%9D%8C\">튜플(Tuple) - <strong><code class=\"language-text\">자바스크립트에서는 다루지 않음</code></strong></a></p>\n</li>\n<li>\n<p><a href=\"#%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8linkedlist\">연결 리스트(LinkedList)</a></p>\n<ul>\n<li><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-1\">시간 복잡도</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-hash-tables--hash-map\">해시 테이블 (Hash Tables / Hash Map)</a></p>\n<ul>\n<li><a href=\"#%EC%B6%A9%EB%8F%8C-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\">충돌 해결 방법</a></li>\n<li><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-2\">시간 복잡도</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%98%95%ED%83%9C%EC%97%90-%EB%94%B0%EB%9D%BC\">형태에 따라</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%84%A0%ED%98%95-%EA%B5%AC%EC%A1%B0\">선형 구조</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%83%9Dstack\">스택(Stack)</a></li>\n<li><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-3\">시간 복잡도</a></li>\n<li><a href=\"#%ED%81%90queue\">큐(Queue)</a></li>\n<li><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-4\">시간 복잡도</a></li>\n<li><a href=\"#%EB%8D%B1deque\">덱(Deque)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B9%84%EC%84%A0%ED%98%95-%EA%B5%AC%EC%A1%B0\">비선형 구조</a></p>\n<ul>\n<li><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84graph\">그래프(Graph)</a></li>\n<li><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-5\">시간 복잡도</a></li>\n<li><a href=\"#%ED%8A%B8%EB%A6%ACtree\">트리(Tree)</a></li>\n<li><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-6\">시간 복잡도</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></p>\n</li>\n</ul>\n</div>","excerpt":"면접을 준비하면서 최근 면접때는 자료구조에 대해서 잘 나오지 않아 생각을 못하고 있었는데, 어제 면접에서 자료구조에 대해서와 장단점 비교에 대한 질문들이 나오게 되었고 나는 당황했다. 그래서 준비가 미비했던걸 인정하고 한번 정리해 보아야겠다. 블로그로 적으면 그래도 한번은 면접때 쭉 볼수 있으니까 말이다. 시간 복잡도에서 대해서 잠깐 알고 아래글을 읽자 아래 글을 읽으면서 시간 복잡도라는 것을 작성했는데,  알고리즘의 로직을 코드로 구현할 때 보통 많이 볼 수 있는데, 시간 복잡도를 고려한다는 말은 ‘입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?’라는 말이다. 효율적인 알고리즘을 구현한다는 것은 시간복잡도를 고려한다는 말이고 다시 말하면 는 이야기이다. 시간 복잡도는 보통  으로 나타낸다. Big-O 표기법은 를 표기하는 방법이다. 자료구조란? 우선 자료구조에 대허서 설명해보려고 한다.  컴퓨터 과학에서 효율적인 접근 및 수정을 가능케 하는 …","frontmatter":{"date":"December 27, 2022","title":"자료구조(Data Structure)란? 그리고 종류","categories":"JavaScript 데이터","author":"JungSany","emoji":"🍄"},"fields":{"slug":"/data/data-structure/structure/"}},"next":{"id":"178169d4-7dff-5bc8-9016-05e51ea39dec","html":"<p><strong>오늘 면접을 보았는데, <code class=\"language-text\">Array와 JavaScript의 Array</code>에 관한 기술질문이 있었고, 이에 대해서 잘 알고있지 않아 글을 정리해보고자 한다.</strong></p>\n<br/>\n<h2 id=\"일반적인-array-밀집-배열\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-array-%EB%B0%80%EC%A7%91-%EB%B0%B0%EC%97%B4\" aria-label=\"일반적인 array 밀집 배열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일반적인 Array (밀집 배열)</h2>\n<p><strong>일반적으로 배열이라는 자료 구조의 개념은</strong></p>\n<ol>\n<li>\n<p><code class=\"language-text\">동일한 크기의 메모리 공간이 빈틈없이 연속적</code>으로 <code class=\"language-text\">나열된 자료 구조</code>를 말한다.</p>\n</li>\n<li>\n<p>배열의 요소는 <code class=\"language-text\">동일한 크기를 갖으며 빈틈없이 연속적으로 이어져 있</code>으므로 <strong>인덱스를 통해 단 한번의 연산으로 임의의 요소에 접근(임의 접근(random access), 시간 복잡도 O(1))할 수 있다. 이는 매우 효율적이며 고속으로 동작한다.</strong></p>\n<p><strong>(하지만 정렬되지 않은 배열에서 특정한 값을 탐색하는 경우, 모든 배열 요소를 처음부터 값을 발견할 때까지 차례대로 탐색(선형 탐색(linear search)을하기 때문에 시간 복잡도는 O(n))이다.)</strong></p>\n</li>\n<li>\n<p>또한 배열에 요소를 <code class=\"language-text\">삽입하거나 삭제하는 경우</code>, 배열 요소를 <code class=\"language-text\">연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점</code>도 있다.</p>\n</li>\n<li>\n<p><strong>즉, 일반적인 Array는 하나의 타입으로 통일되어 있으며 서로 연속적으로 인접해 있기 때문에 이러한 배열을 <code class=\"language-text\">밀집 배열(dense array)</code>이라 한다.</strong></p>\n</li>\n</ol>\n<p><img src=\"https://poiemaweb.com/assets/fs-images/27-1.png\" alt=\"일반적인 Array 이미지\"></p>\n<br/>\n<h2 id=\"javascript의-array-희소-배열\" style=\"position:relative;\"><a href=\"#javascript%EC%9D%98-array-%ED%9D%AC%EC%86%8C-%EB%B0%B0%EC%97%B4\" aria-label=\"javascript의 array 희소 배열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaScript의 Array (희소 배열)</h2>\n<p><strong>JavaScript의 Array은 일반적인 Array와는 다른데, 그 이유는</strong></p>\n<ol>\n<li>\n<p><strong>자바스크립트에서 배열은 일반적인 배열의 동작을 흉내낸 특수한 객체(Array 객체)이다.</strong></p>\n<p><strong><code class=\"language-text\">(인덱스를 프로퍼티 키로 갖으며 length 프로퍼티를 갖는 특수한 객체)</code></strong></p>\n</li>\n<li>\n<p><strong>자바스크립트에서는 <code class=\"language-text\">모든 값이 객체의 프로퍼티 값이 될 수 있</code>으므로 <code class=\"language-text\">어떠한 타입의 값이라도 배열의 요소가 될 수 있다.</code></strong></p>\n</li>\n<li>\n<p><strong>배열의 요소가 연속적으로 이어져 있지 않는 배열을 <code class=\"language-text\">희소 배열(sparse array)</code>이라 한다.</strong></p>\n</li>\n</ol>\n<br/>\n<h3 id=\"length-프로퍼티와-희소배열\" style=\"position:relative;\"><a href=\"#length-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%ED%9D%AC%EC%86%8C%EB%B0%B0%EC%97%B4\" aria-label=\"length 프로퍼티와 희소배열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>length 프로퍼티와 희소배열</h3>\n<p>length 프로퍼티는 배열의 길이를 나타내는 0이상의 정수를 값으로 갖는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span>\n\narr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 4</span>\n\narr<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span></code></pre></div>\n<p>length 프로퍼티에 임의의 값을 할당할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\narr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1, 2, 3]</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\narr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 6</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [ 1, 2, 3, &lt;3 empty items> ]</span></code></pre></div>\n<p>위 코드에서 출력 결과를 확인해 보았을 때, <code class=\"language-text\">arr 변수</code>에 선언된 length 프로퍼티의 값보다 큰 숫자의 length를 할당하게 되면 length의 길이는 변경되지만, 실제 <code class=\"language-text\">arr 변수</code>에는 아무런 변화가 없기 때문에 <code class=\"language-text\">3 empty items</code>라는 console.log에 찍히게 되는 것을 확인 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptors</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*\n  {\n    '0': { value: 1, writable: true, enumerable: true, configurable: true },\n    '1': { value: 2, writable: true, enumerable: true, configurable: true },\n    '2': { value: 3, writable: true, enumerable: true, configurable: true },\n    length: { value: 6, writable: true, enumerable: false, configurable: false }\n  }\n/*</span></code></pre></div>\n<p><code class=\"language-text\">getOwnPropertyDescriptors()</code>를 통해서 확인 사살을 해보면 값이 없는 요소를 위해 메모리 공간을 확보하지 않은 것을 확인할 수 있다.</p>\n<p>이처럼 배열의 요소가 연속적으로 위치하지 않고 일부가 비어 있는 배열을 <code class=\"language-text\">희소 배열</code>이라고 한다.</p>\n<br/>\n<h2 id=\"장단점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장단점</h2>\n<p><strong><code class=\"language-text\">일반적인 Array은</code> 인덱스로 배열 요소에 빠르게 접근할 수 있다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않다.</strong></p>\n<p><strong><code class=\"language-text\">자바스크립트 Array은</code> 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우, 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적인 단점을 갖는다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.</strong></p>\n<p><strong>즉, 자바스크립트 배열은 인덱스로 배열 요소에 접근하는 경우에는 일반적인 배열보다 느리지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠르다.</strong></p>\n<br/>\n<h3 id=\"자바스크립트의-배열과-객체-비교\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%B0%B0%EC%97%B4%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EB%B9%84%EA%B5%90\" aria-label=\"자바스크립트의 배열과 객체 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트의 배열과 객체 비교</h3>\n<p><code class=\"language-text\">자바스크리브의 배열은</code> 인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수 밖에 없는 구조적인 단점을 보완하기 위해 <code class=\"language-text\">배열을 일반 객체와 구별하여 보다 배열처럼 동작하도록 최적화하여 구현</code>하였다.</p>\n<p>아래는 모던자바스크립트 예제를 가져왔다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Array Performance Test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Array Performance Test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 약 340ms</span>\n\n<span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Object Performance Test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  obj<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Object Performance Test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 약 600ms</span></code></pre></div>\n<br/>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array\">MDN - Array</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\">MDN - Array.isArray()</a></p>\n<p><a href=\"https://poiemaweb.com/js-array-is-not-arrray\">모던자바스크립트 - 자바스크립트 배열은 배열이 아니다</a></p>\n<p><a href=\"http://tcpschool.com/javascript/js_array_basic\">TCP - 배열의 기초</a></p>\n<p><a href=\"https://velog.io/@yongjin9660/JavaScript-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC%EA%B3%A0\">[JavaScript] 배열이 배열이 아니라고?</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-array-%EB%B0%80%EC%A7%91-%EB%B0%B0%EC%97%B4\">일반적인 Array (밀집 배열)</a></p>\n</li>\n<li>\n<p><a href=\"#javascript%EC%9D%98-array-%ED%9D%AC%EC%86%8C-%EB%B0%B0%EC%97%B4\">JavaScript의 Array (희소 배열)</a></p>\n<ul>\n<li><a href=\"#length-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%ED%9D%AC%EC%86%8C%EB%B0%B0%EC%97%B4\">length 프로퍼티와 희소배열</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\">장단점</a></p>\n<ul>\n<li><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%B0%B0%EC%97%B4%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EB%B9%84%EA%B5%90\">자바스크립트의 배열과 객체 비교</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 26, 2022","title":"Array와 JavaScript의 Array","categories":"JavaScript","author":"JungSany","emoji":"🍑"},"fields":{"slug":"/javascript/array-javascriptarray/"}},"prev":{"id":"f443910b-72ee-5673-9a27-9fcc7156cd8a","html":"<h1 id=\"v8-javascript-engine이란\" style=\"position:relative;\"><a href=\"#v8-javascript-engine%EC%9D%B4%EB%9E%80\" aria-label=\"v8 javascript engine이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 JavaScript engine이란?</h1>\n<p><strong>C++로 작성된 Google의 오픈 소스 고성능 JavaScript 및 WebAssembly 엔진이다.</strong></p>\n<p><strong>Chrome 및 Node.js 등에서 사용된다.</strong></p>\n<p><strong>V8과 다른 엔진의 가장 큰 차이점은 V8 엔진의 <code class=\"language-text\">JIT(Just In Time)</code> 컴파일러다.</strong></p>\n<br/>\n<h2 id=\"jit-cjust-in-time-compiler\" style=\"position:relative;\"><a href=\"#jit-cjust-in-time-compiler\" aria-label=\"jit cjust in time compiler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JIT-C(Just In Time Compiler)</h2>\n<p><img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&#x26;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb2Jzmc%2Fbtq56j9e47D%2FNPkxYsJWSRNgS7OrsGc9mK%2Fimg.png\" alt=\"JIT 이미지\"></p>\n<p><strong>일반적인 Compiler 방식에는 <code class=\"language-text\">동적 컴파일(interpreter)</code>과 <code class=\"language-text\">정적 컴파일(Compiler)</code>이 있다.</strong></p>\n<p><strong><code class=\"language-text\">JIT(Just In Time)은</code></strong> 이 두개의 컴파일 방식을 합친 것으로 실행시점에서 인터프리터 방식으로 바이트 코드를 생성한다.</p>\n<p>그 후 <strong><code class=\"language-text\">V8 Engine은</code></strong> 바이트 코드를 기계어 코드로 만들고, 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.</p>\n<br/>\n<h2 id=\"v8의-컴파일-과정\" style=\"position:relative;\"><a href=\"#v8%EC%9D%98-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95\" aria-label=\"v8의 컴파일 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8의 컴파일 과정</h2>\n<p><img src=\"https://miro.medium.com/max/700/1*F0lz3L4l9n6W-O2ivkvjtg.jpeg\" alt=\"V8의 컴파일 과정 이미지\"></p>\n<ol>\n<li>Blink에서 <code class=\"language-text\">script 태그</code>를 만나면, Javascript 스트리밍을 시작한다.</li>\n<li>스트리밍으로 전달 받은 UTF-16 문자열은 Scanner를 이용해 Token(let, for)을 생성한다.</li>\n<li>생성된 Token을 가지고, Parser가 추상 구문 트리 (AST)를 만든다.</li>\n<li>만들어진 AST는 Ignition(Compiler)에서 Byte Code로 컴파일한다.</li>\n<li>컴파일된 Byte Code를 실행함으로써 원하는 Javascript 동작이 실행된다.</li>\n</ol>\n<br/>\n<h2 id=\"용어사전\" style=\"position:relative;\"><a href=\"#%EC%9A%A9%EC%96%B4%EC%82%AC%EC%A0%84\" aria-label=\"용어사전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>용어사전</h2>\n<p><strong>인터프리터(interpreter)</strong> : 한줄읽고 실행하는 방식으로, 동일한 동작을 하는 함수가 여러번 나오더라도 이를 컴파일 하는 과정을 거치게 한다. 따라서 이는 <code class=\"language-text\">매우 비효율적</code>이다. 하지만 <code class=\"language-text\">디버깅에 유리</code>할 수 있다. <code class=\"language-text\">V8</code>은 <code class=\"language-text\">JIT Compiler</code>을 지원하는데 인터프리터 방식의 비효율적인 방법을 방지하게 만든다.</p>\n<p><strong>컴파일러(compiler)</strong> : 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 언어 번역 프로그램으로 코드를 실행하기 전에 소스코드 전체를 컴파일 한다. 이는 개발 편의성은 떨어지지만, 실행 속도는 높을 수 있다.</p>\n<p><strong>JIT 컴파일(just in time compilation) 또는 동적 번역(dynamic translation)</strong> : 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이며, V8 엔진에서 기용하는 기법</p>\n<p><strong>AST(Abstract Syntax Tree)</strong> : 프로그래밍 언어로 작성된 소스 코드의 추상 구문 구조의 트리로, 각 노드는 소스 코드에서 발생되는 구조를 나타낸다.</p>\n<p><strong>TurboFan JIT Compiler</strong> : 바이트 코드를 실행하면서 Profiler는 최적화(Optimizes)가 가능한 부분을 찾아서 기록해둔다. (<strong>자주 쓰이는 변수나 함수, 최적화 방법으로는</strong> <code class=\"language-text\">히든 클래스</code>, <code class=\"language-text\">인라인 캐싱</code>이 있다.)</p>\n<br/>\n<h2 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h2>\n<p><a href=\"https://v8.dev/\">V8</a></p>\n<p><a href=\"https://v8.dev/blog/ignition-interpreter\">Firing up the Ignition interpreter</a></p>\n<p><a href=\"https://hwan-shell.tistory.com/343\">V8 Engine에 대해서…(메모리구조, 컴파일방식)</a></p>\n<p><a href=\"https://ui.toast.com/posts/ko_20210909\">자바스크립트 성능의 비밀 (V8과 히든 클래스)</a></p>\n<p><a href=\"https://youtu.be/r5OWCtuKiAk\">BlinkOn 6 Day 1 Talk 2: Ignition - an interpreter for V8</a></p>\n<p><a href=\"https://pks2974.medium.com/v8-%EC%97%90%EC%84%9C-javascript-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0-25837f61f551\">V8 에서 Javascript 코드를 실행하는 방법 정리해보기</a></p>\n<p><a href=\"https://deepu.tech/memory-management-in-v8/\">🚀 Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a></p>\n<p><a href=\"https://ko.javascript.info/garbage-collection\">가비지 컬렉션 - 모던 JavaScript 튜토리얼</a></p>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#jit-cjust-in-time-compiler\">JIT-C(Just In Time Compiler)</a></li>\n<li><a href=\"#v8%EC%9D%98-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95\">V8의 컴파일 과정</a></li>\n<li><a href=\"#%EC%9A%A9%EC%96%B4%EC%82%AC%EC%A0%84\">용어사전</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 28, 2022","title":"V8 JavaScript engine에 대해서","categories":"JavaScript 개발지식","author":"JungSany","emoji":"🌐"},"fields":{"slug":"/knowledge/v8-engine/"}},"site":{"siteMetadata":{"siteUrl":"https://rnfltpgus.github.io","comments":{"utterances":{"repo":"rnfltpgus/rnfltpgus.github.io"}}}}},"pageContext":{"slug":"/data/data-structure/structure/","nextSlug":"/javascript/array-javascriptarray/","prevSlug":"/knowledge/v8-engine/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
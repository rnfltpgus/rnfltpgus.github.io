---
emoji: ⛈️
title: 쿠키와 세션 그리고 토큰(인증과 인가)
date: '2022-12-12 19:28:00'
author: JungSany
tags: blog gatsby jung log cookies session token certification permission http
categories: 개발지식
---

### 인증과 인가 정의

- **전달, 공개하기 위한 방법으로**
  - **인증 :** (식별가능한 정보로) 서비스에 등록된 유저의 신원을 입증하는 과정
  - **인가 :** 인증된 사용자에 대한 자원 접근 권한 확인

<br/>

### HTTP의 특징과 쿠키와 세션을 사용하는 이유

- HTTP 프로토콜의 특성이자 약점을 보완하기 위해 `쿠키와 세션`을 사용
- **기본적으로** HTTP 프로토콜 환경은 “connectionless(무연고), stateless(국적없는)” 한 즉, **`무상태성의 특성`**을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야되는데, 이를 해결하기 위해서 쿠키와 세션, 그리고 추가적으로 토큰을 사용하게 되었다.

<br/>

### 쿠키(Cookie)

- **쿠키란?**
  - `넥스케이프`에서 쿠키를 개발하였다.
  - 클라이언트(브라우저) `로컬 PC`에 `저장`된다.
  - `작은 데이터 파일`로 구성되어 있으며, 브라우저 환경마다 다르긴하지만 `4KB 이하`로 데이터를 보낼 수 있다.
  - `키와 벨류의 형태`로 구성되어 있으며, `string 형식`이다.
  - 사용자 인증이 `유효한 시간을 명시`할 수 있으며, 유효 시간이 정해지면 `브라우저가 종료되어도 인증이 유지`되는 특징이 있다.(날짜를 정해주면 `지속쿠키`, 안 정해주면 `세션쿠키` [참고](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#:~:text=If%20unspecified%2C%20the%20cookie%20becomes%20a%20session%20cookie.%20A%20session%20finishes%20when%20the%20client%20shuts%20down%2C%20after%20which%20the%20session%20cookie%20is%20removed))
  - 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 `Request시에 RequestHeader를 넣어서 자동으로 서버에 전송`합니다.
  - 세션보다 요청 속도가 빠름
- **쿠키의 동작 방식**
  1. 클라이언트가 페이지를 요청
  2. 서버에서 쿠키를 생성
  3. HTTP 헤더에 쿠키를 포함 시켜 응답
  4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
  5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
  6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답
- **사용 예시**
  - **방문 사이트에서 로그인 시**, “아이디와 비밀번호를 저장하시겠습니까?” - **지속쿠키**
  - **쇼핑몰의 장바구니 기능 - 세션쿠키**
  - **자동로그인, 팝업에서** “오늘 더 이상 이 창을 보지 않음” 체크, 쇼핑몰의 장바구니 - **지속쿠키**
- **쿠키의 한계**
  - 민감한 정보를 그대로 HTTP 통신에 노출하는 경우 탈취당할 수 있다.
  - 아이디와 패스워드를 쿠키에 넣어서 모든 요청마다 인증 정보를 포함하게 할 수 있는데, 통신 과정에서 패킷을 가로채가면 패스워드가 유출될 수 있다.
  - **쿠키의 보안 취약점을 보완**하기 위해 `세션`이 등장하였다.

<br/>

### 세션(Session)

- **세션이란?**
  - `세션은 쿠키를 기반`으로 하고 있다. (하지만 사용자 정보 파일을 브라우저에 저장하는 쿠키와는 다르게 `서버 측에서 관리`한다.)
  - 서버에서는 클라이언트를 구분하기 위해 `세션ID`를 부여하며 `웹 브라우저`가 서버 접속해서 브라우저를 `종료할 때까지 인증상태를 유지`한다.
  - `접속 시간`에 `제한`을 두어 일정 시간 응답이 없다면 `정보가 유지`되지 않게 `설정이 가능`하다.
  - 사용자에 대한 `정보를 서버에 두기` 때문에 쿠키보다 `보안상 좋지만`, `사용자가 많을 경우` 메모리를 많이 차지하게 되어 `서버과부하나 성능 저하의 요인이 되기도 한다.`
  - 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 `세션ID`이다.
  - **세션의 핵심은 HTTP 통신 상에서는 `어떠한 민감한 정보도 오가지 않는다는 것`이다.**
    - 민감한 정보는 `오직 서버와 세션 스토리지에서만` 다뤄지고 외부로 노출되지 않는다.
- **세션의 동작 방식**
  1. 클라이언트가 서버에 접속 시, 세션 ID를 발급 받음
  2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음
  3. 클라리언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청
  4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라언트 정보를 가져와서 사용
  5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답
- **세션의 특징**
  - 각 클라이언트에게 `고유 ID`를 부여
  - 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
  - `보안 면에서 쿠키보다 우수`
  - 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨
- **사용 예시**
  - **로그인 같이 보안상 중요한 작업을 수행할 때** 사용
- **세션의 한계**
  - 쿠키에 담긴 정보가 있는 그대로 의미 없지만, 탈취한 쿠키를 이용해 서버에 요청을 보내면 정보가 유출될 수 있다.(세션 하이재킹)
  - 서버에 정보를 저장해야 하기 때문에 메모리 공간을 차지한다.
  - 쿠키로부터 받은 세션 ID로 세션 스토리지를 탐색해야 하는 시간이 든다.
  - 동시 접속자가 많은 서비스의 경우 서버 과부하의 원인이 된다. 이후 서버에 정보를 저장하지 않는 토큰이 등장 하였다.

<br/>

### 쿠키와 세션의 차이

|                          | 쿠키(Cookie)                                                                        | 세션(Session)                                                                                    |
| ------------------------ | ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| 저장 위치                | 클라이언트(=접속자 PC)                                                              | 웹 서버                                                                                          |
| 저장 형식                | String(text)                                                                        | Object                                                                                           |
| 만료 시점(라이프 사이클) | 쿠키 저장시 설정 (브라우저가 종료되도, 만료시점이 지나지 않으면 자동삭제 되지 않음) | 브라우저 종료시 삭제 (만료시점 지정이 가능하지만 브라우저가 종료되면 지정시간과 상관없이 삭제됨) |
| 사용하는 자원(리소스)    | 클라이언트 리소스                                                                   | 웹 서버 리소스                                                                                   |
| 용량 제한                | 총 300개 ,하나의 토메인 당 20개,하나의 쿠키 당 4KB(3096byte)                        | 서버가 혀용하는 한 용량제한 없음                                                                 |
| 속도                     | 세션보다 빠름                                                                       | 쿠키보다 느림                                                                                    |
| 보안                     | 세션보다 안좋음                                                                     | 쿠키보다 좋음                                                                                    |

<br/>

### Token

`서버`는 인증에 필요한 정보들을 암호화시켜 토큰을 발행하고, `클라이언트`는 발행받은 토큰을 HTTP 헤더에 계속 넣어서 요청을 보내는 방식

![토큰작동방식](https://tech.lawandgood.com/images/2021/10/04/Untitled%2012.png)

- **클라이언트의 인증 Request**
  - 클라이언트는 아이디, 패스워드 등의 인증정보를 HTTP 요청에 담아서 서버에 전달
- **서버의 인증 정보 확인 및 Response + Token**
  - 서버는 클라이언트로부터 받은 인증 정보가 유효한지 확인하고, 토큰을 HTTP 응답에 담아서 전달
  - 토큰은 Secret Key로 암호화되어 있고, 유효기간이 설정되어 있다.
- **HTTP with Token**
  - 클라이언트는 서버로부터 발급받은 토큰을 HTTP 헤더에 담아서 요청을 보내고, 서버는 토큰이 유효한지 검사하여 인증 여부를 판별한다.
  - 토큰은 `Seecret Key`로 복호화하여 유효한지 아닌지 판별할 수 있기 때문에 `별도의 저장 공간이 필요하지 않다.` 따라서 **세션 방식의 단점인 서버 과부하**를 줄여줄 수 있다.
- **토큰의 한계**
  - 이미 발급된 토큰은 유효기간이 만료되기 전까지 계속 사용할 수 있기 때문에, 악의적으로 이용될 수 있다. 따라서 토큰 유효기간을 짧게 하고 `Refresh Token`을 새로 발급해야 한다.
  - `토큰의 길이`가 쿠키, 세션에 비해 `길어서` 인증이 필요한 요청이 많을 때 `서버 자원낭비가 발생`한다.

<br/>

### 정리

- `쿠키와 세션을 비교`하였을 때, 세션을 사용하면 좋을 것 같은데 쿠키와 같이 섞어서 사용하는 이유는
- **세션이 쿠키에 비해 보안도 높은 편이나 쿠키를 사용하는 이유는 세션은 서버에 저장되고, 서버자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원이 상당하며, 속도가 느려질 수 있기 때문이다.**
- **이러한 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용해야 서버 자원의 낭비를 방지하고 웹 사이트 속도를 높일 수 있다.**
- 세션의 단점을 인 서버 과부하를 줄일 수 있는 토큰 방식은 길이가 길어 서버 자원 낭비가 발생할 수도 있다. 그래서 세션과 토큰 방식을 모두 섞어서 써야하는 건가?
- 토큰은 토큰으로 상태관리를 하기 때문에 세션을 둘 필요가 없다. 그렇기 때문에 효율성이 좋아지고 DB를 찔러보지 않아도 되기 때문에 속도가 빠르다는 장점이 있다. 하지만 토큰도 결국 탈취당할 수 있기 때문에 관리를 해야한다.
- **`발전순서`는 Fat URL → 쿠키 → 세션 → 토큰**
  - 여기서 Fat URL은 고유 ID를 넣어서 클라이언트를 식별하는 방법으로 사용자의 행동을 추적하여 개인화 된 웹 사이트를 제공했다고 한다.
    - 단점: URL이 못났다, URL을 공유할 수 없다, URL을 유지하지 못하고 이탈할 가능성이 크다.

<br/>

### 남이 정리한 한줄 정리

- **쿠키 이전의 방식** : 사용자를 정확하게 식별할 수가 없다 → 브라우저에 명시적으로 누구인지 기록하자!
- **쿠키** : 쿠키를 탈취당하면 개인정보가 유출된다 → 민감한 정보는 브라우저에 주지 말고 서버에 두자!
- **세션** : 세션을 저장하기 위한 공간과 응답 속도가 지연된다 → 저장하지 말고 암호화한 토큰을 줘버리자!
- **토큰** : 토큰을 탈취하여 악의적으로 사용할 수 있다 → Refresh 토큰을 써서 유효기간을 짧게 하자!

<br/>

### 더 알면 좋을 것 같은 것

- 쿠키와 세션은 캐시와 다르다
  - 캐시는 이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해 놓고 사용한다.
  - 한번 캐시에 저장되면 브라우저를 참고하기 떄문에 서버에서 변경이 되어도 사용자는 브라우저에서 변경되지 않은 화면을 볼 경우도 있다. 이런 부분을 해결하기 위해서는 캐시를 지워주거나 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료 시간을 명시하는 방법 등을 이용할 수 있다.

<br/>

### 용어정리

- **connectionless:** 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징
- **stateless(무상태성):** 통신이 끝나면 상태를 유지하지 않는 특성
- **쿠키의 구성 요소**
  - 이름: 각각의 쿠키를 구별하는 데 사용되는 이름
  - 값: 쿠키의 이름과 관련된 값
  - 유효시간: 쿠키의 유지시간
  - 도메인: 쿠키를 전송할 도메인
  - 경로: 쿠키를 전송할 요청 경로
- **Domain:** HTTP 요청을 보낼 주소의 도메인이 Domain 속성값과 같은 경우에만 쿠키를 보낸다.
  - **도메인이란?** 인터넷에 연결된 컴퓨터를 사람이 쉽게 기억하고 입력할 수 있도록 문자(영문, 한글 등)로 만든 인터넷 주소
- **Path:** HTTP 요청을 보낼 주소의 URL 경로가 Path 속성값과 같은 경우에만 쿠키를 보낸다.
- **Load Balancer:** 워크로드를 가상 서버와 같은 다수의 컴퓨팅 리소스로 분산한다. 또는 서버에 가해지는 트래픽을 여러대의 서버에게 균등하게 분산시켜주는 역할

<br/>

### 참고링크

[HTTP로부터 발생한 쿠키, 세션, 토큰](https://tech.lawandgood.com/web-client-identification/)

[[10분 테코톡] 🎡토니의 인증과 인가](https://www.youtube.com/watch?v=y0xMXlOAfss)

[[10분 테코톡] 🤠루피의 인증과 인가](https://www.youtube.com/watch?v=JZgD8aPkHSc)

[[10분 테코톡] 연로그의 쿠키 vs 세션 vs 토큰 vs 캐시](https://www.youtube.com/watch?v=gA1KsJ2ak10&list=RDCMUC-mOekGSesms0agFntnQang&start_radio=1&t=353s)

[쿠키와 세션 개념](https://interconnection.tistory.com/m/74)

<br/>

```toc

```
